<html>

        <head>
            <script type="text/javascript" src="brython.js"></script>
        </head>

<script type="text/javascript"
    src="brython_stdlib.js">
</script>

        <body onload="brython()">

<script type="text/python">
from browser import document, alert

print("begin imports")

print("loading importlib")
import importlib
print("loading os")
import os
print("loading sys")
import sys
print("loading from io import StringIO")
from io import StringIO
print("loading itertools")
import itertools
#import dis
#from dis import findlabels  # dis has no 'findlabels'
#from array import array
print("loading types")
import types
print("loading operator")
import operator
print("loading opcode")
import opcode
#print("loading pdb")
#import pdb # pdb eh inutil!
print("loading collections")
import collections
print("loading from collections import OrderedDict")
from collections import OrderedDict
print("loading binascii")
import binascii

#will import specific dis.py from python 3.5
print("loading dis.py")

from opcode import *
from opcode import __all__ as _opcodes_all

__all__ = ["code_info", "dis", "disassemble", "distb", "disco",
           "findlinestarts", "findlabels", "show_code",
           "get_instructions", "Instruction", "Bytecode"] + _opcodes_all
del _opcodes_all

_have_code = (types.MethodType, types.FunctionType, types.CodeType,
              classmethod, staticmethod, type)

def _try_compile(source, name):
    """Attempts to compile the given source, first as an expression and
       then as a statement if the first approach fails.

       Utility function to accept strings in functions that otherwise
       expect code objects
    """
    try:
        c = compile(source, name, 'eval')
    except SyntaxError:
        c = compile(source, name, 'exec')
    return c

def dis(x=None, *, file=None):
    """Disassemble classes, methods, functions, generators, or code.

    With no argument, disassemble the last traceback.

    """
    if x is None:
        distb(file=file)
        return
    if hasattr(x, '__func__'):  # Method
        x = x.__func__
    if hasattr(x, '__code__'):  # Function
        x = x.__code__
    if hasattr(x, 'gi_code'):  # Generator
        x = x.gi_code
    if hasattr(x, '__dict__'):  # Class or module
        items = sorted(x.__dict__.items())
        for name, x1 in items:
            if isinstance(x1, _have_code):
                print("Disassembly of %s:" % name, file=file)
                try:
                    dis(x1, file=file)
                except TypeError as msg:
                    print("Sorry:", msg, file=file)
                print(file=file)
    elif hasattr(x, 'co_code'): # Code object
        disassemble(x, file=file)
    elif isinstance(x, (bytes, bytearray)): # Raw bytecode
        _disassemble_bytes(x, file=file)
    elif isinstance(x, str):    # Source code
        _disassemble_str(x, file=file)
    else:
        raise TypeError("don't know how to disassemble %s objects" %
                        type(x).__name__)

def distb(tb=None, *, file=None):
    """Disassemble a traceback (default: last traceback)."""
    if tb is None:
        try:
            tb = sys.last_traceback
        except AttributeError:
            raise RuntimeError("no last traceback to disassemble")
        while tb.tb_next: tb = tb.tb_next
    disassemble(tb.tb_frame.f_code, tb.tb_lasti, file=file)

# The inspect module interrogates this dictionary to build its
# list of CO_* constants. It is also used by pretty_flags to
# turn the co_flags field into a human readable list.
COMPILER_FLAG_NAMES = {
     1: "OPTIMIZED",
     2: "NEWLOCALS",
     4: "VARARGS",
     8: "VARKEYWORDS",
    16: "NESTED",
    32: "GENERATOR",
    64: "NOFREE",
   128: "COROUTINE",
   256: "ITERABLE_COROUTINE",
}

def pretty_flags(flags):
    """Return pretty representation of code flags."""
    names = []
    for i in range(32):
        flag = 1<<i
        if flags & flag:
            names.append(COMPILER_FLAG_NAMES.get(flag, hex(flag)))
            flags ^= flag
            if not flags:
                break
    else:
        names.append(hex(flags))
    return ", ".join(names)

def _get_code_object(x):
    """Helper to handle methods, functions, generators, strings and raw code objects"""
    if hasattr(x, '__func__'): # Method
        x = x.__func__
    if hasattr(x, '__code__'): # Function
        x = x.__code__
    if hasattr(x, 'gi_code'):  # Generator
        x = x.gi_code
    if isinstance(x, str):     # Source code
        x = _try_compile(x, "<disassembly>")
    if hasattr(x, 'co_code'):  # Code object
        return x
    raise TypeError("don't know how to disassemble %s objects" %
                    type(x).__name__)

def code_info(x):
    """Formatted details of methods, functions, or code."""
    return _format_code_info(_get_code_object(x))

def _format_code_info(co):
    lines = []
    lines.append("Name:              %s" % co.co_name)
    lines.append("Filename:          %s" % co.co_filename)
    lines.append("Argument count:    %s" % co.co_argcount)
    lines.append("Kw-only arguments: %s" % co.co_kwonlyargcount)
    lines.append("Number of locals:  %s" % co.co_nlocals)
    lines.append("Stack size:        %s" % co.co_stacksize)
    lines.append("Flags:             %s" % pretty_flags(co.co_flags))
    if co.co_consts:
        lines.append("Constants:")
        for i_c in enumerate(co.co_consts):
            lines.append("%4d: %r" % i_c)
    if co.co_names:
        lines.append("Names:")
        for i_n in enumerate(co.co_names):
            lines.append("%4d: %s" % i_n)
    if co.co_varnames:
        lines.append("Variable names:")
        for i_n in enumerate(co.co_varnames):
            lines.append("%4d: %s" % i_n)
    if co.co_freevars:
        lines.append("Free variables:")
        for i_n in enumerate(co.co_freevars):
            lines.append("%4d: %s" % i_n)
    if co.co_cellvars:
        lines.append("Cell variables:")
        for i_n in enumerate(co.co_cellvars):
            lines.append("%4d: %s" % i_n)
    return "\n".join(lines)

def show_code(co, *, file=None):
    """Print details of methods, functions, or code to *file*.

    If *file* is not provided, the output is printed on stdout.
    """
    print(code_info(co), file=file)

_Instruction = collections.namedtuple("_Instruction",
     "opname opcode arg argval argrepr offset starts_line is_jump_target")

class Instruction(_Instruction):
    """Details for a bytecode operation

       Defined fields:
         opname - human readable name for operation
         opcode - numeric code for operation
         arg - numeric argument to operation (if any), otherwise None
         argval - resolved arg value (if known), otherwise same as arg
         argrepr - human readable description of operation argument
         offset - start index of operation within bytecode sequence
         starts_line - line started by this opcode (if any), otherwise None
         is_jump_target - True if other code jumps to here, otherwise False
    """

    def _disassemble(self, lineno_width=3, mark_as_current=False):
        """Format instruction details for inclusion in disassembly output

        *lineno_width* sets the width of the line number field (0 omits it)
        *mark_as_current* inserts a '-->' marker arrow as part of the line
        """
        fields = []
        # Column: Source code line number
        if lineno_width:
            if self.starts_line is not None:
                lineno_fmt = "%%%dd" % lineno_width
                fields.append(lineno_fmt % self.starts_line)
            else:
                fields.append(' ' * lineno_width)
        # Column: Current instruction indicator
        if mark_as_current:
            fields.append('-->')
        else:
            fields.append('   ')
        # Column: Jump target marker
        if self.is_jump_target:
            fields.append('>>')
        else:
            fields.append('  ')
        # Column: Instruction offset from start of code sequence
        fields.append(repr(self.offset).rjust(4))
        # Column: Opcode name
        fields.append(self.opname.ljust(20))
        # Column: Opcode argument
        if self.arg is not None:
            fields.append(repr(self.arg).rjust(5))
            # Column: Opcode argument details
            if self.argrepr:
                fields.append('(' + self.argrepr + ')')
        return ' '.join(fields).rstrip()


def get_instructions(x, *, first_line=None):
    """Iterator for the opcodes in methods, functions or code

    Generates a series of Instruction named tuples giving the details of
    each operations in the supplied code.

    If *first_line* is not None, it indicates the line number that should
    be reported for the first source line in the disassembled code.
    Otherwise, the source line information (if any) is taken directly from
    the disassembled code object.
    """
    co = _get_code_object(x)
    cell_names = co.co_cellvars + co.co_freevars
    linestarts = dict(findlinestarts(co))
    if first_line is not None:
        line_offset = first_line - co.co_firstlineno
    else:
        line_offset = 0
    return _get_instructions_bytes(co.co_code, co.co_varnames, co.co_names,
                                   co.co_consts, cell_names, linestarts,
                                   line_offset)

def _get_const_info(const_index, const_list):
    """Helper to get optional details about const references

       Returns the dereferenced constant and its repr if the constant
       list is defined.
       Otherwise returns the constant index and its repr().
    """
    argval = const_index
    if const_list is not None:
        argval = const_list[const_index]
    return argval, repr(argval)

def _get_name_info(name_index, name_list):
    """Helper to get optional details about named references

       Returns the dereferenced name as both value and repr if the name
       list is defined.
       Otherwise returns the name index and its repr().
    """
    argval = name_index
    if name_list is not None:
        argval = name_list[name_index]
        argrepr = argval
    else:
        argrepr = repr(argval)
    return argval, argrepr


def _get_instructions_bytes(code, varnames=None, names=None, constants=None,
                      cells=None, linestarts=None, line_offset=0):
    """Iterate over the instructions in a bytecode string.

    Generates a sequence of Instruction namedtuples giving the details of each
    opcode.  Additional information about the code's runtime environment
    (e.g. variable names, constants) can be specified using optional
    arguments.

    """
    labels = findlabels(code)
    starts_line = None
    free = None
    for offset, op, arg in _unpack_opargs(code):
        if linestarts is not None:
            starts_line = linestarts.get(offset, None)
            if starts_line is not None:
                starts_line += line_offset
        is_jump_target = offset in labels
        argval = None
        argrepr = ''
        if arg is not None:
            #  Set argval to the dereferenced value of the argument when
            #  available, and argrepr to the string representation of argval.
            #    _disassemble_bytes needs the string repr of the
            #    raw name index for LOAD_GLOBAL, LOAD_CONST, etc.
            argval = arg
            if op in hasconst:
                argval, argrepr = _get_const_info(arg, constants)
            elif op in hasname:
                argval, argrepr = _get_name_info(arg, names)
            elif op in hasjrel:
                argval = offset + 3 + arg
                argrepr = "to " + repr(argval)
            elif op in haslocal:
                argval, argrepr = _get_name_info(arg, varnames)
            elif op in hascompare:
                argval = cmp_op[arg]
                argrepr = argval
            elif op in hasfree:
                argval, argrepr = _get_name_info(arg, cells)
            elif op in hasnargs:
                argrepr = "%d positional, %d keyword pair" % (arg%256, arg//256)
        yield Instruction(opname[op], op,
                          arg, argval, argrepr,
                          offset, starts_line, is_jump_target)

def disassemble(co, lasti=-1, *, file=None):
    """Disassemble a code object."""
    cell_names = co.co_cellvars + co.co_freevars
    linestarts = dict(findlinestarts(co))
    _disassemble_bytes(co.co_code, lasti, co.co_varnames, co.co_names,
                       co.co_consts, cell_names, linestarts, file=file)

def _disassemble_bytes(code, lasti=-1, varnames=None, names=None,
                       constants=None, cells=None, linestarts=None,
                       *, file=None, line_offset=0):
    # Omit the line number column entirely if we have no line number info
    show_lineno = linestarts is not None
    # TODO?: Adjust width upwards if max(linestarts.values()) >= 1000?
    lineno_width = 3 if show_lineno else 0
    for instr in _get_instructions_bytes(code, varnames, names,
                                         constants, cells, linestarts,
                                         line_offset=line_offset):
        new_source_line = (show_lineno and
                           instr.starts_line is not None and
                           instr.offset > 0)
        if new_source_line:
            print(file=file)
        is_current_instr = instr.offset == lasti
        print(instr._disassemble(lineno_width, is_current_instr), file=file)

def _disassemble_str(source, *, file=None):
    """Compile the source string, then disassemble the code object."""
    disassemble(_try_compile(source, '<dis>'), file=file)

disco = disassemble                     # XXX For backwards compatibility

def _unpack_opargs(code):
    # enumerate() is not an option, since we sometimes process
    # multiple elements on a single pass through the loop
    extended_arg = 0
    n = len(code)
    i = 0
    while i < n:
        op = code[i]
        offset = i
        i = i+1
        arg = None
        if op >= HAVE_ARGUMENT:
            arg = code[i] + code[i+1]*256 + extended_arg
            extended_arg = 0
            i = i+2
            if op == EXTENDED_ARG:
                extended_arg = arg*65536
        yield (offset, op, arg)

def findlabels(code):
    """Detect all offsets in a byte code which are jump targets.

    Return the list of offsets.

    """
    labels = []
    for offset, op, arg in _unpack_opargs(code):
        if arg is not None:
            label = -1
            if op in hasjrel:
                label = offset + 3 + arg
            elif op in hasjabs:
                label = arg
            if label >= 0:
                if label not in labels:
                    labels.append(label)
    return labels

def findlinestarts(code):
    """Find the offsets in a byte code which are start of lines in the source.

    Generate pairs (offset, lineno) as described in Python/compile.c.

    """
    byte_increments = list(code.co_lnotab[0::2])
    line_increments = list(code.co_lnotab[1::2])

    lastlineno = None
    lineno = code.co_firstlineno
    addr = 0
    for byte_incr, line_incr in zip(byte_increments, line_increments):
        if byte_incr:
            if lineno != lastlineno:
                yield (addr, lineno)
                lastlineno = lineno
            addr += byte_incr
        lineno += line_incr
    if lineno != lastlineno:
        yield (addr, lineno)

class Bytecode:
    """The bytecode operations of a piece of code

    Instantiate this with a function, method, string of code, or a code object
    (as returned by compile()).

    Iterating over this yields the bytecode operations as Instruction instances.
    """
    def __init__(self, x, *, first_line=None, current_offset=None):
        self.codeobj = co = _get_code_object(x)
        if first_line is None:
            self.first_line = co.co_firstlineno
            self._line_offset = 0
        else:
            self.first_line = first_line
            self._line_offset = first_line - co.co_firstlineno
        self._cell_names = co.co_cellvars + co.co_freevars
        self._linestarts = dict(findlinestarts(co))
        self._original_object = x
        self.current_offset = current_offset

    def __iter__(self):
        co = self.codeobj
        return _get_instructions_bytes(co.co_code, co.co_varnames, co.co_names,
                                       co.co_consts, self._cell_names,
                                       self._linestarts,
                                       line_offset=self._line_offset)

    def __repr__(self):
        return "{}({!r})".format(self.__class__.__name__,
                                 self._original_object)

    @classmethod
    def from_traceback(cls, tb):
        """ Construct a Bytecode from the given traceback """
        while tb.tb_next:
            tb = tb.tb_next
        return cls(tb.tb_frame.f_code, current_offset=tb.tb_lasti)

    def info(self):
        """Return formatted information about the code object."""
        return _format_code_info(self.codeobj)

    def dis(self):
        """Return a formatted view of the bytecode operations."""
        co = self.codeobj
        if self.current_offset is not None:
            offset = self.current_offset
        else:
            offset = -1
        with io.StringIO() as output:
            _disassemble_bytes(co.co_code, varnames=co.co_varnames,
                               names=co.co_names, constants=co.co_consts,
                               cells=self._cell_names,
                               linestarts=self._linestarts,
                               line_offset=self._line_offset,
                               file=output,
                               lasti=offset)
            return output.getvalue()


# Will include neo-boa files in this sequence
#byteplay3.py
#boa/code/pyop.py
#boa/code/line.py
#boa/blockchain/vm/VMOp.py
#boa/code/pytoken.py
#boa/blockchain/vm/BigInteger.py
#boa/code/vmtoken.py
#boa/code/block.py
#boa/code/method.py
#boa/code/items.py
#boa/code/module.py
#boa/compiler.py
#boacompiler.py


class pyop_base:
    POP_TOP = 1
    ROT_TWO = 2
    ROT_THREE = 3
    DUP_TOP = 4
    DUP_TOP_TWO = 5

    NOP = 9
    UNARY_POSITIVE = 10
    UNARY_NEGATIVE = 11
    UNARY_NOT = 12

    UNARY_INVERT = 15

    BINARY_MATRIX_MULTIPLY = 16
    INPLACE_MATRIX_MULTIPLY = 17

    BINARY_POWER = 19
    BINARY_MULTIPLY = 20

    BINARY_MODULO = 22
    BINARY_ADD = 23
    BINARY_SUBTRACT = 24
    BINARY_SUBSCR = 25
    BINARY_FLOOR_DIVIDE = 26
    BINARY_TRUE_DIVIDE = 27
    INPLACE_FLOOR_DIVIDE = 28
    INPLACE_TRUE_DIVIDE = 29

    GET_AITER = 50
    GET_ANEXT = 51
    BEFORE_ASYNC_WITH = 52

    INPLACE_ADD = 55
    INPLACE_SUBTRACT = 56
    INPLACE_MULTIPLY = 57

    INPLACE_MODULO = 59
    STORE_SUBSCR = 60
    DELETE_SUBSCR = 61
    BINARY_LSHIFT = 62
    BINARY_RSHIFT = 63
    BINARY_AND = 64
    BINARY_XOR = 65
    BINARY_OR = 66
    INPLACE_POWER = 67
    GET_ITER = 68
    GET_YIELD_FROM_ITER = 69

    PRINT_EXPR = 70
    LOAD_BUILD_CLASS = 71
    YIELD_FROM = 72
    GET_AWAITABLE = 73

    INPLACE_LSHIFT = 75
    INPLACE_RSHIFT = 76
    INPLACE_AND = 77
    INPLACE_XOR = 78
    INPLACE_OR = 79
    BREAK_LOOP = 80
    WITH_CLEANUP_START = 81
    WITH_CLEANUP_FINISH = 82

    RETURN_VALUE = 83
    IMPORT_STAR = 84

    YIELD_VALUE = 86
    POP_BLOCK = 87
    END_FINALLY = 88
    POP_EXCEPT = 89


    HAVE_ARGUMENT = 90              # Opcodes from here have an argument:

    STORE_NAME = 90       # Index in name list
    DELETE_NAME = 91      # ""
    UNPACK_SEQUENCE = 92   # Number of tuple items

    FOR_ITER = 93  # jrel op

    UNPACK_EX = 94
    STORE_ATTR = 95       # Index in name list
    DELETE_ATTR = 96      # ""
    STORE_GLOBAL = 97     # ""
    DELETE_GLOBAL = 98    # ""
    LOAD_CONST = 100       # Index in const list

    # hasconst.append(100

    LOAD_NAME = 101       # Index in name list
    BUILD_TUPLE = 102      # Number of tuple items
    BUILD_LIST = 103       # Number of list items
    BUILD_SET = 104        # Number of set items
    BUILD_MAP = 105        # Number of dict entries (upto 255
    LOAD_ATTR = 106       # Index in name list
    COMPARE_OP = 107       # Comparison operator

    IMPORT_NAME = 108     # Index in name list
    IMPORT_FROM = 109     # Index in name list

    JUMP_FORWARD = 110    # Number of bytes to skip
    JUMP_IF_FALSE_OR_POP = 111  # Target byte offset from beginning of code
    JUMP_IF_TRUE_OR_POP = 112  # "jabs op"
    JUMP_ABSOLUTE = 113        # "jabs op"
    POP_JUMP_IF_FALSE = 114    # "jabs op"
    POP_JUMP_IF_TRUE = 115     # "jabs op"

    LOAD_GLOBAL = 116     # Index in name list

    CONTINUE_LOOP = 119   # Target address jrel
    SETUP_LOOP = 120      # Distance to target address jrel
    SETUP_EXCEPT = 121    # "jrel"
    SETUP_FINALLY = 122   # "jrel"

    LOAD_FAST = 124        # Local variable number
    STORE_FAST = 125       # Local variable number
    DELETE_FAST = 126      # Local variable number

    RAISE_VARARGS = 130    # Number of raise arguments (1, 2, or 3
    CALL_FUNCTION = 131    # #args + (#kwargs << 8


    MAKE_FUNCTION = 132    # Number of args with default values
    BUILD_SLICE = 133      # Number of items
    MAKE_CLOSURE = 134
    LOAD_CLOSURE = 135

    LOAD_DEREF = 136

    STORE_DEREF = 137

    DELETE_DEREF = 138

    CALL_FUNCTION_VAR = 140     # #args + (#kwargs << 8
    CALL_FUNCTION_KW = 141      # #args + (#kwargs << 8
    CALL_FUNCTION_VAR_KW = 142  # #args + (#kwargs << 8

    SETUP_WITH = 143

    LIST_APPEND = 145
    SET_ADD = 146
    MAP_ADD = 147

    LOAD_CLASSDEREF = 148

    SETUP_ASYNC_WITH = 154

    EXTENDED_ARG = 144

    BUILD_LIST_UNPACK = 149
    BUILD_MAP_UNPACK = 150
    BUILD_MAP_UNPACK_WITH_CALL = 151
    BUILD_TUPLE_UNPACK = 152
    BUILD_SET_UNPACK = 153


    # boa custom ops

    FROMALTSTACK = 241
    DROP = 242

    BR_S = 243

    SETITEM = 244

    LD_ELEMENT = 245

    XSWAP = 246
    ROLL = 247

    DROP_BODY = 248

# XXX END boa/code/pyop.py


# XXX BEGIN byteplay3.py
print("loading byteplay3.py")

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# The __all__ global establishes the complete API of the module on import.
# "from byteplay import *" imports these names, plus a bunch of names of
# opcodes. Although this form of import is usually deprecated, it makes
# sense in this case because code that uses byteplay almost always needs
# access to the set of opcode names.
#

__all__ = ['cmp_op',
           'Code',
           'CodeList',
           'getse',
           'hasarg',
           'hascode',
           'hascompare',
           'hasjabs',
           'hasjrel',
           'hasjump',
           'haslocal',
           'hasname',
           'hasfree',
           'hasflow',
           'isopcode',
           'Label',
           'object_attributes',
           'Opcode',
           'opmap',
           'opname',
           'opcodes',
           'print_object_attributes',
           'print_attr_values',
           'printcodelist',
           'SetLineno',
           #'stack_effect'  # AYGOR
           ]

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Because this module uses a number of standard modules that are not
# commonly used in typical code, some import statements are annotated.

#import sys
#from io import StringIO
#import itertools # used for .izip()
#from dis import findlabels

# An array('B') object is used to represent a bytecode string when creating a
# code object, see to_code()
#from array import array
#import types # used for CodeType and FunctionType
#import operator # names for standard operators such as __eq__

# The opcode module is standard, distributed in lib/python3.v, but is NOT
# documented in docs.python.org/3.v/. It says it is "shared between dis and
# other modules which operate on bytecodes". Anyway, opcode defines all
# the bytecodes and their attributes under various names.
#
# Byteplay basically plunders opcode and re-creates its exported names with
# more information or different organization, which is discussed in the
# comments below.
#import opcode

# From the standard module dis grab this function, defined as "Detect all
# offsets in a byte code which are jump targets. Return the list of offsets."



#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Check the Python version. We support 3.x only.

python_version = '.'.join(str(x) for x in sys.version_info[:2])
if sys.version_info.major != 3 :
    print( "This version of BytePlay requires Python 3", file=sys.stderr )
    exit
elif sys.version_info.minor < 3 :  # era 4!!! XXX AYGOR
    print( "This version of byteplay requires Python 3.4 or later", file=sys.stderr )
    exit

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Define some functions that are useful in exploring function objects
# and code objects.
#
def object_attributes( thing, all=False ) :
    '''
    Return a sorted list of names defined by thing that are not also names in
    a standard object, except include __doc__.
    '''
    standard_names = set( dir( object() ) )
    things_names = set( dir( thing ) )
    if not all :
        things_names -= standard_names
        things_names |= set( ['__doc__'] )
    return sorted( things_names )

def print_object_attributes( thing, heading=None, file=None ):
    '''
    Print the attribute names in thing vertically
    '''
    if heading : print( '==', heading, '==', file=file )
    print( '\n'.join( object_attributes( thing ) ), file=file )

def print_attr_values( thing, all=False, heading=None, file=None ):
    '''
    Print the attributes of thing which have non-empty values,
    as a vertical list of "name : value". When all=True, print
    all attributes even those with empty values.
    '''
    if heading :
        if isinstance( heading, int ) :
            # request for default heading
            heading = '== {} attributes of {} =='.format(
                            'all' if all else 'non-empty',
                            getattr( thing, '__name__', str(thing) )
            )
        print( heading, file=file )

    for attr in object_attributes( thing, all ):
        attr_value = getattr( thing, attr )
        if attr_value is not None :
            print( attr, ':', attr_value, file=file )
        elif all :
            print( attr, ':' )


#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Define opcodes and information about them, basically extending the values
# presented by module opcode. The global opname, mentioned in the Opcode
# class definition, is established just below.
#

class Opcode(int):
    """
    An int which represents an opcode but its str() is the opcode name,
    for example
        Opcode(1).__str__() --> 'POP_TOP'
        Opcode(1).__repr__() --> 'Opcode(1)'
        int(Opcode(1)) --> 1
    """
    def __str__( self ):
        return opname.get(self,str(self.real))
    def __repr__( self ):
        return 'Opcode(%s)' % int(self)

# opcode.opmap is a dict of { "op_name" : op_int_value }. Here we make our
# own opmap in which op_int_value is an Opcode object rather than a simple
# int. Also, leave out 'EXTENDED_ARG'/144, which is not really an opcode,
# but merely a kludge that allows Python to encode argument values >2^16
# in the opcode bytestream. See note on the CodeList class.

opmap = { name: Opcode( bytecode )
          for name, bytecode in opcode.opmap.items()
          if name != 'EXTENDED_ARG'
        }

# opname is the inverse of opmap, dict { op_int_value : "op_name" }.
# (This is quite different from opcode.opname which is only a list.)

opname = { bytecode: name for name, bytecode in opmap.items() }

# opcodes is a set of the keys of dict opname, hence of valid bytecode
# values, for quick testing.

opcodes = set( opname.keys() )

# Now force all opcode names into our global namespace, so e.g. POP_TOP is a
# global variable with value Opcode(1).
#
# The names of these globals are also added to global __all__ (defined above)
# so they are part of our API.

for name, code in opmap.items():
    globals()[name] = code
    __all__.append(name)

# Resolve the difference between Python 3.4 and 3.5 to a single name.
# Note this name is not exported in __all__. Solve your own version diffs!
if sys.version_info.minor == 3 : # must be 4 AYGOR XXX
    _WITH_CLEANUP_OPCODE = 81 #WITH_CLEANUP
else :
    _WITH_CLEANUP_OPCODE = WITH_CLEANUP_START

# Add opcode.cmp_op to our API (the name "cmp_op" is in __all__ already). It
# is a tuple of the Python comparison operator names such as "<=" and "is
# not". These are the strings that can appear as the argument value of the
# COMPARE_OP bytecode.

cmp_op = opcode.cmp_op

# Make sets of Opcode objects that have particular properties. Each of these
# "hasxxx" names is in our API __all__.
#
# Define the set of the opcodes that...
#
# ... take a cmp_op as their argument (only COMPARE_OP):

hascompare = set(Opcode(x) for x in opcode.hascompare)

# ... HAVE_ARGUMENT, which is all those above 90 (currently). "x in hasarg"
# is a more readable test than "x >= HAVE_ARGUMENT"

hasarg = set(x for x in opcodes if x >= opcode.HAVE_ARGUMENT)
# Note that EXTENDED_ARG was excluded from the opcodes set, which is ok
# however an EXTENDED_ARG opcode does have an arg (by definition, yo) and
# needs to be handled with other members of hasarg in _from_code(). Frankly I
# do not see how the original byteplay could work without this. I'm
# dubious if they ever processed an actual EXTENDED_ARG example.
hasargx = hasarg | set( (Opcode( opcode.EXTENDED_ARG ),) )

# ... have a constant argument (currently only 100=LOAD_CONST)

hasconst = set(Opcode(x) for x in opcode.hasconst)

# ... have a name argument, e.g. LOAD_GLOBAL, DELETE_ATTR

hasname = set(Opcode(x) for x in opcode.hasname)

# ... have a relative-jump-target argument, e.g. FOR_ITER

hasjrel = set(Opcode(x) for x in opcode.hasjrel)

# ... have an absolute jump-target argument, e.g. JUMP_IF_FALSE_OR_POP

hasjabs = set(Opcode(x) for x in opcode.hasjabs)

# ... have any kind of jump (so much easier with sets not lists)

hasjump = hasjrel.union(hasjabs)

# ..refer to a local variable, e.g. STORE_FAST

haslocal = set(Opcode(x) for x in opcode.haslocal)

# ..refer to a "free" variable, e.g. LOAD_CLOSURE

hasfree = set(Opcode(x) for x in opcode.hasfree)

# ..refer to a code object at TOS1 with function name at TOS

print("chegou ate aqui!")

hascode = set( [ Opcode(pyop_base.MAKE_FUNCTION), Opcode(pyop_base.MAKE_CLOSURE) ] )

# ..may not continue to the next sequential instruction


hasflow = hasjump | set( [ Opcode(pyop_base.BREAK_LOOP),
                 Opcode(pyop_base.RETURN_VALUE),
                 Opcode(pyop_base.YIELD_VALUE),
                 Opcode(pyop_base.YIELD_FROM),
                 Opcode(pyop_base.POP_BLOCK),
                 Opcode(pyop_base.POP_EXCEPT),
                 Opcode(pyop_base.END_FINALLY),
                 Opcode(pyop_base.RAISE_VARARGS),
                 Opcode(pyop_base.CALL_FUNCTION)
                 ] ) | set(
                     [ Opcode(op)
                       for (name, op) in opmap.items()
                       if name.startswith('WITH_CLEANUP')
                    ] )



# Pass on the opcode.stack_effect() routine (which is actually implemented
# in CPython Modules/_opcode.c) as part of our API.
#
# Reading the code of compile.c:PyCompile_OpcodeStackEffect() it handles
# every defined opcode except two: NOP and EXTENDED_ARG. NOP is possible
# as a place-holder, so handle it here. EXTENDED_ARG is not a real opcode
# and should not get queried in this way.
#
# Also the CPython code only looks at args that are ints, so if the actual
# arg is, e.g., a string (as it might be for, e.g. LOAD_FAST), pass it as
# a zero.

def stack_effect( op, arg ):
    if op == opcode.EXTENDED_ARG or not op in opcodes :
        raise ValueError( 'Attempt to get stack effect of invalid opcode' )
    if op == NOP :
        return 0
    passed_arg = None
    if op in hasarg :
        try:
            passed_arg = int( arg )
        except:
            # arg not an int, compile.c doesn't care about it
            passed_arg = 0
    return opcode.stack_effect( op, passed_arg )

def getse( op, arg ):
    net_change = stack_effect( op, arg )
    if net_change < 0 :
        # op pops more than it pushes so...
        return ( abs( net_change ), 0 )
    else :
        # op pushes the same or more than it pops, so...
        return ( 0, net_change )


#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#

class CodeList(list):
    """
A CodeList is an expanded version of a Python code byte-string.

The contents of a CodeList is a series of tuples (Opcode, argument) where
Opcode is an Opcode object based on the bytecode, and argument is either
None or the actual argument value of the opcode.

Argument values are typically integers, but they can be Python type at all.
For example if a function defines an inner function, one of its first opcodes
is (LOAD_CONST, <python code object>) where the constant value is an entire
code object, in effect a large byte array. The from_code() method recursively
encodes such values as nested Code objects.

In an actual bytecode string, opcode arguments are represented as indexes
into a tuple of constants. In a CodeList, the actual argument constant values
are present in the tuple, not an index.

Also in an actual bytecode string, an integer argument that does not fit in
16 bits is represented as a sequence of 1 or more EXTENDED_ARG opcodes. In
the CodeList, the extra bits are gathered into a single long int and the
EXTENDED_ARG bytecode is dropped.

The __str__() result of a CodeList is a formatted disassembly as a large
string, one line per bytecode. The printcodelist() function was used to
produce this disassembly in the original code. It is retained for
compatibility.

Note that CodeList __init__ method exists (to set self.changed=False) but any
argument is passed on to the parent list class. Normally there is no
argument, just x=CodeList(). It might seem like a logical move to have the
__init__() take a code bytestring and build itself, but unfortunately a
bytestring is not self-interpreting; it requires use of other slots of a code
object (code.lnotab etc). So the code that constructs a CodeList is embedded
inside the from_code() method.

CodeList is a derivative of a standard list class. The only override of
normal list behavior is the __str__() function.

    """
    def __init__( self, *args ):
        super().__init__( *args )
        self.changed = False

    def __str__(self):
        """
    Convert the current contents into a nice disassembly in multiple
    lines, in the manner of dis.dis. Here is a random sample:

    2           0 SETUP_LOOP              24 (to 27)
                3 LOAD_FAST                0 (L)
                6 GET_ITER
          >>    7 FOR_ITER                16 (to 26)
               10 STORE_FAST               1 (item)

        """
        output = [] # list of strings being created

        labeldict = {}
        pendinglabels = []
        for i, ( op, arg ) in enumerate( self ):
            if isinstance(op, Label):
                pendinglabels.append( op )
            elif isinstance( op, SetLinenoType ):
                pass
            else:
                while pendinglabels:
                    labeldict[ pendinglabels.pop() ] = i

        lineno = None
        islabel = False
        for i, ( op, arg ) in enumerate( self ):
            if isinstance( op, SetLinenoType ):
                # This code item is a marker of a source line number, which is
                # not a bytecode. Set up so that the NEXT opcode will display the
                # line number in the left margin. Output a blank line here.
                lineno = arg    # note line number value
                output.append('') # insert the blank line
                continue # the loop

            if isinstance(op, Label):
                # This code item is a label marker, which is not a real Python
                # bytecode. It doesn't display in the output but it does
                # condition the NEXT opcode to have a ">>" marker.
                islabel = True
                continue # the loop without any output

            # Set up the current line number, if any, or a null string, to
            # print to the left of this item. In case it was a line number,
            # clear the flag.
            linenostr =  str(lineno) if lineno else ''
            lineno = None

            # Set up the ">>" jump-target marker if this code item is a
            # target, and clear that flag.
            islabelstr = '>>' if islabel else ''
            islabel = False

            # Set up the argument value to follow the opcode on the same line.
            if op in hasconst:
                # argument is const
                argstr = repr(arg)
            elif op in hasjump:
                # argument is jump target
                if arg in labeldict :
                    argstr = 'to ' + str( labeldict[arg] )
                else :
                    argstr = repr( arg )
            elif op in hasarg:
                # argument is something
                argstr = str( arg )
            else:
                # nope, no argument needed
                argstr = ''

            line = '%4s   %2s %4d %-20s %s' % (
                linenostr,
                islabelstr,
                i,
                op,
                argstr
            )
            output.append( line )
        return '\n'.join( output ) + '\n'

def _get_a_code_object_from( thing ) :
    '''
    Given a thing that might be a property, a class method,
    a function or a code object, reduce it to code object.
    If we cannot, return the thing itself.
    '''
    # If we were passed a Method wrapper, get its function
    if isinstance( thing, types.MethodType ) :
        thing = thing.__func__
    # If we were passed a property object, get its getter function
    # (no direct support for the fdel or fset functions)
    if hasattr( thing, 'fget' ) :
        thing = thing.fget
    # If we were passed, or now have, a function, get its code object.
    if isinstance( thing, types.FunctionType ) :
        thing = thing.__code__
    # We should now have a code object, or will never have it.
    return thing


def printcodelist(thing, to=sys.stdout, heading=None):
    '''
    Write the lines of the codelist string list to the given file, or to
    the default output.

    A little Python 3 problem: if the to-file is in binary mode, we need to
    encode the strings, else a TypeError will be raised. Obvious answer, test
    for 'b' in to.mode? Nope, only "real" file objects have a mode attribute.
    StringIO objects, and the variant StringIO used as default sys.stdout, do
    not have .mode.

    However, all file-like objects that support string output DO have an
    encoding attribute. (StringIO has one that is an empty string, but it
    exists.) So, if hasattr(to,'encoding'), just shove the whole string into
    it. Otherwise, encode the string utf-8 and shove that bytestring into it.
    (See? Python 3 not so hard...)

    '''
    # If we were passed a list, assume that it is a CodeList or
    # a manually-assembled list of code tuples.
    if not isinstance( thing, list ) :
        # Passed something else. Reduce it to a CodeList.
        if isinstance( thing, Code ):
            thing = thing.code
        else :
            # Convert various sources to a code object.
            thing = _get_a_code_object_from( thing )
            try :
                thing = Code.from_code( thing ).code
            except Exception as e:
                raise ValueError('Invalid input to printcodelist')
    # We have a CodeList or equivalent,
    # get the whole disassembly as a string.
    whole_thang = str( thing )
    # if destination not a text file, encode it to bytes
    if not hasattr( to, 'encoding' ) :
        whole_thang = whole_thang.encode( 'UTF-8' )
        if heading : # is not None or empty
            heading = heading.encode( 'UTF-8' )
    # send it on its way
    if heading :
        to.write( '===' + heading + '===\n' )
    to.write( whole_thang )


# Besides real opcodes our CodeList object may feature two non-opcodes One is
# the Set Line Number action, represented by a single global object of its
# class (which is exported in __all__)...

class SetLinenoType(object):
    def __init__(self):
        super().__init__()
        self.__str__ = self.__repr__
    def __repr__(self):
        return 'SetLineno'

SetLineno = SetLinenoType()

# Two, the Label type which represents the target of a jump. (There is no
# bytecode in a real codestring for this; it is implicit in the numeric
# arguments of "hasjump" opcodes. The class Label is also in __all__.

class Label(object):
    pass

# This boolean function allows distinguishing real opcodes in a CodeList from
# the two non-opcode types. Note there should only ever exist the one
# instance of SetLinenoType, the global SetLineno. But who knows?

def isopcode(obj):
    """
    Return whether obj is an opcode - not SetLineno or Label
    """
    return not isinstance(obj, SetLinenoType) and not isinstance(obj, Label)

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
#
# Define the Code class, which represents a Python code object in a
# more accessible format -- see docstring below.

# Flags from code.h. These flags appear in the co_coflags member of the
# code object. When converting from a code object (from_code(), below)
# some of them are isolated and converted into Code object members.
# When recreating a code object from a Code one, the flags are created
# based on Code object members and contents.

CO_OPTIMIZED              = 0x0001      # use LOAD/STORE_FAST instead of _NAME
CO_NEWLOCALS              = 0x0002      # only cleared for module/exec code
CO_VARARGS                = 0x0004      # signature contains *arg
CO_VARKEYWORDS            = 0x0008      # signature contains **kwargs
CO_NESTED                 = 0x0010      # ???
CO_GENERATOR              = 0x0020      # func contains "yield" opcode
CO_NOFREE                 = 0x0040      # quick test for "no free or cell vars"
CO_COROUTINE              = 0x0080      # func created with "async def"
CO_ITERABLE_COROUTINE     = 0x0100      # async def func has "yield"
# The following flags are no longer used as of 3.4
CO_GENERATOR_ALLOWED      = 0x1000      # unused
CO_FUTURE_DIVISION        = 0x2000
CO_FUTURE_ABSOLUTE_IMPORT = 0x4000
CO_FUTURE_WITH_STATEMENT  = 0x8000
CO_FUTURE_PRINT_FUNCTION  = 0x10000
CO_FUTURE_UNICODE_LITERALS = 0x20000
CO_FUTURE_BARRY_AS_BDFL   = 0x40000 # Barry White. No, byte array.
CO_FUTURE_GENERATOR_STOP  = 0x80000

class Code(object):
    """

    An object that holds all the information that a Python code object holds,
    but in an easy-to-play-with representation.

    Code offers the following class method:

    Code.from_code(code_object): analyzes a Python code object and returns
    an instance of Code class that has equivalent contents.

    The attributes of any Code object are:

    to_code()
        analyzes the contents and returns a Python code object with
        equivalent contents.

    code
        the code as CodeList; see class CodeList above.

    freevars
        list of strings, names of "free" vars of the code. Technically a "free"
        variable should be one that is used in the code but not defined in it.
        In CPython terminology it is one that is used in this code and known
        to be defined in an enclosing scope = outer function.

    args
        list of strings, the names of arguments to a function.

    varargs
        boolean: Does the function's arg list contain a '*args' argument?

    varkwargs
        boolean: Does the function's arg list end with a '**kwargs' argument?

    kwonlyargcount
        int: the count of keyword-only arguments (those that followed the
        *args in the signature of the def statement).

    newlocals
        boolean: Should a new local namespace be created? (True in functions,
        False for module and exec code)

    coflags
        int: the original co_flags value of the code object given to
        from_code(). Can be interrogated for CO_COROUTINE, CO_GENERATOR,
        CO_ITERABLE_COROUTINE, CO_OPTIMIZED. If to_code() finds that
        the code list is unchanged since from_code() built it, these
        flags are reproduced in the output.

    name
        string: the name of the code, from co_name.

    filename
        string: the file name of the code, from co_filename.

    firstlineno
        int: the first source line number, from co_firstlineno

    docstring
        string or None: the docstring, i.e. the first item of co_consts,
        when that is a string.

    """

    # Usually a Code object is created by the class method from_code() below.
    # However you can create one directly by supplying at least a CodeList.
    # Due to the substantial argument list, this, like the code object
    # itself, is "not for the faint of heart".

    def __init__(self,
                 code,
                 freevars = [],
                 args = [],
                 varargs = False,
                 varkwargs = False,
                 kwonlyargcount = 0,
                 newlocals = False,
                 coflags = 0x00,
                 name = '',
                 filename = '',
                 firstlineno = 1,
                 docstring = ''
                 ) :
        self.code = code
        self.freevars = freevars
        self.args = args
        self.varargs = varargs
        self.varkwargs = varkwargs
        self.kwonlyargcount = kwonlyargcount
        self.newlocals = newlocals
        self.coflags = coflags
        self.name = name
        self.filename = filename
        self.firstlineno = firstlineno
        self.docstring = docstring

    @staticmethod
    def _findlinestarts(code_object):
        """
        Find the offsets in a byte code which are the start of source lines.

        Generate pairs (offset, lineno) as described in Python/compile.c.

        This is a modified version of dis.findlinestarts. This version allows
        multiple "line starts" with the same line number. (The dis version
        conditions its yield on a test "if lineno != lastlineno".)

        FYI: code.co_lnotab is a byte array with one pair of bytes for each
        effective source line number in the bytecode. An effective line is
        one that generates code: not blank or comment lines. The first actual
        line number, typically the number of the "def" statement, is in
        code.co_firstlineno.

        An even byte of co_lnotab is the offset to the bytecode generated
        from the next effective line number. The following odd byte is an
        increment on the previous line's number to the next line's number.
        Thus co_firstlineno+co_lnotab[1] is the first effective line's
        number, and co_lnotab[0] is the number of bytes it generated.

        Note that an effective line number generates code by definition,
        hence the even byte cannot be zero; and as line numbers are
        monotonically increasing, the odd byte cannot be zero either.

        But what, the curious reader might ask, does Python do if a source
        line generates more than 255 bytes of code? In that *highly* unlikely
        case compile.c generates multiple pairs of (255,0) until it has
        accounted for all the generated code, then a final pair of
        (offset%256, lineincr).

        Oh, but what, the curious reader asks, do they do if there is a gap
        of more than 255 between effective line numbers? It is not unheard of
        to find blocks of comments larger than 255 lines (like this one?).
        Then compile.c generates pairs of (0, 255) until it has accounted for
        the line number difference and a final pair of (offset,lineincr%256).

        Uh, but...? Yes, what now, annoying reader? Well, does the following
        code handle these special cases of (255,0) and (0,255) properly?
        It handles the (0,255) case correctly, because of the "if byte_incr"
        test which skips the yield() but increments lineno. It does not handle
        the case of (255,0) correctly; it will yield false pairs (255,0).
        Fortunately that will only arise e.g. when disassembling some
        "obfuscated" code where most newlines are replaced with semicolons.

        Oh, and yes, the to_code() method does properly handle generation
        of the (255,0) and (0,255) entries correctly.

        """
        # grab the even bytes as integer byte_increments:
        byte_increments = [c for c in code_object.co_lnotab[0::2]]
        # grab the odd bytes as integer line_increments:
        line_increments = [c for c in code_object.co_lnotab[1::2]]

        lineno = code_object.co_firstlineno
        addr = 0
        for byte_incr, line_incr in zip(byte_increments, line_increments):
            if byte_incr:
                yield (addr, lineno)
                addr += byte_incr
            lineno += line_incr
        yield (addr, lineno)

    @classmethod
    def from_code(cls, code_object):
        """
        Disassemble a Python code object and make a Code object from the bits.
        This is the expected way to make a Code instance. But you are welcome
        to call Code() directly if you wish.
        """
        # get the actual bytecode string out of the code object
        co_code = code_object.co_code

        # Use dis.findlabels to locate the labeled bytecodes, that is, the
        # ones that are jump targets. (They are "labeled" in a disassembly
        # printout.) Store the list as a dict{ addr: Label object} for easy
        # lookup.

        labels = dict((addr, Label()) for addr in findlabels(co_code))

        # Make a dict{ source_line : offset } for the source lines in the code.

        linestarts = dict(cls._findlinestarts(code_object))

        cellfree = code_object.co_cellvars + code_object.co_freevars

        # Create a CodeList object to represent the bytecode string.

        code = CodeList()   # receives (op,arg) tuples
        n = len(co_code)    # number bytes in the bytecode string
        i = 0               # index over the bytecode string
        extended_arg = 0    # upper 16 bits of an extended arg

        # Iterate over the bytecode string expanding it into (Opcode,arg) tuples.

        while i < n:
            # First byte is the opcode
            op = Opcode( co_code[i] )

            # If this op is a jump-target, insert (Label,) ahead of it.
            if i in labels:
                code.append((labels[i], None))

            # If this op is the first from a source line, insert
            # (SetLineno, line#) ahead of it.
            if i in linestarts:
                code.append((SetLineno, linestarts[i]))

            i += 1 # step index to the argument if any

            if op not in hasargx :
                # No argument, push the minimal tuple, done.
                code.append((op, None))
            else:
                # op takes an argument. Look for MAKE_FUNCTION or MAKE_CLOSURE.
                if op in hascode :
                    # special case: with these opcodes, at runtime, TOS1 should
                    # be a code object. We require the normal opcode sequence:
                    #    LOAD_CONST the code object
                    #    LOAD_CONST the name of the function
                    #    MAKE_FUNCTION/CLOSURE
                    # When this exists, go back and convert the argument of the
                    # first LOAD_CONST from a code object to a Code object.
                    if len(code) >= 2 \
                       and code[-2][0] == LOAD_CONST \
                       and code[-1][0] == LOAD_CONST \
                       and isinstance( code[-2][1], types.CodeType ) :
                        code[-2] = ( Opcode(LOAD_CONST), Code.from_code( code[-2][1] ) )
                    else :
                        raise ValueError(
                            'Invalid opcode sequence for MAKE_FUNCTION/MAKE_CLOSURE'
                        )
                    # now continue and handle the argument of MAKE_F/C normally.

                # Assemble the argument value from two bytes plus an extended
                # arg when present.
                arg = co_code[i] + co_code[i+1]*256 + extended_arg
                extended_arg = 0 # clear extended arg bits if any
                i += 2 # Step over the argument

                if op == opcode.EXTENDED_ARG:
                    # The EXTENDED_ARG op is just a way of storing the upper
                    # 16 bits of a 32-bit arg in the bytestream. Collect
                    # those bits, but generate no code tuple.
                    extended_arg = arg << 16

                elif op in hasconst:
                    # When the argument is a constant, put the constant
                    # itself in the opcode tuple. If that constant is a code
                    # object, the test above (if op in hascode) will later
                    # convert it into a Code object.
                    code.append((op, code_object.co_consts[arg]))

                elif op in hasname:
                    # When the argument is a name, put the name string itself
                    # in the opcode tuple.
                    code.append((op, code_object.co_names[arg]))

                elif op in hasjabs:
                    # When the argument is an absolute jump, put the label
                    # in the tuple (in place of the label list index)
                    code.append((op, labels[arg]))

                elif op in hasjrel:
                    # When the argument is a relative jump, put the label
                    # in the tuple in place of the forward offset.
                    code.append((op, labels[i + arg]))

                elif op in haslocal:
                    # When the argument is a local var, put the name string
                    # in the tuple.
                    code.append((op, code_object.co_varnames[arg]))

                elif op in hascompare:
                    # When the argument is a relation (like ">=") put that
                    # string in the tuple instead.
                    code.append((op, cmp_op[arg]))

                elif op in hasfree:
                    code.append((op, cellfree[arg]))

                else:
                    # whatever, just put the arg in the tuple
                    code.append((op, arg))

        # Store certain flags from the code object as booleans for convenient
        # reference as Code members.

        varargs = bool(code_object.co_flags & CO_VARARGS)
        varkwargs = bool(code_object.co_flags & CO_VARKEYWORDS)
        newlocals = bool(code_object.co_flags & CO_NEWLOCALS)

        # Get the names of arguments as strings, from the varnames tuple. The
        # order of name strings in co_varnames is:
        #   co_argcount names of regular (positional-or-keyword) arguments
        #   names of co_kwonlyargcount keyword-only arguments if any
        #   name of a *vararg argument
        #   name of a **kwarg argument if any (not present if kwonlyargs > 0)
        #   names of other local variables
        # Hence the count of argument names is
        #   co_argcount + co_kwonlyargcount + varargs + varkwargs
        nargs = code_object.co_argcount + code_object.co_kwonlyargcount + varargs + varkwargs
        args = code_object.co_varnames[ : nargs ]

        # Preserve a docstring if any. If there are constants and the first
        # constant is a string, Python assumes that's a docstring.
        docstring = None
        if code_object.co_consts and isinstance(code_object.co_consts[0], str):
            docstring = code_object.co_consts[0]

        # Funnel all the collected bits through the Code.__init__() method.
        return cls( code = code,
                    freevars = code_object.co_freevars,
                    args = args,
                    varargs = varargs,
                    varkwargs = varkwargs,
                    kwonlyargcount = code_object.co_kwonlyargcount,
                    newlocals = newlocals,
                    coflags = code_object.co_flags,
                    name = code_object.co_name,
                    filename = code_object.co_filename,
                    firstlineno = code_object.co_firstlineno,
                    docstring = docstring
                    )

    # Define equality between Code objects the same way that codeobject.c
    # implements the equality test, by ORing the inequalities of each part.
    # If all attributes are equal, then test the individual tuples of the
    # two CodeList objects.

    def __eq__(self, other):
        if (self.freevars != other.freevars or
            self.args != other.args or
            self.varargs != other.varargs or
            self.varkwargs != other.varkwargs or
            self.kwonlyargcount != other.kwonlyargcount or
            self.newlocals != other.newlocals or
            self.name != other.name or
            self.filename != other.filename or
            self.firstlineno != other.firstlineno or
            self.docstring != other.docstring or
            len(self.code) != len(other.code)
            ):
            return False

        # Compare code. For codeobject.c this would be a comparison of two
        # bytestrings, but this is harder because of extra info, e.g. labels
        # should be matching, not necessarily identical.
        labelmapping = {}
        for (op1, arg1), (op2, arg2) in itertools.izip(self.code, other.code):
            if isinstance(op1, Label):
                if labelmapping.setdefault(op1, op2) is not op2:
                    return False
            else:
                if op1 != op2:
                    return False
                if op1 in hasjump:
                    if labelmapping.setdefault(arg1, arg2) is not arg2:
                        return False
                elif op1 in hasarg:
                    if arg1 != arg2:
                        return False
        return True

    # Re-create the co_flags value based in part on the booleans we pulled
    # out into the Code object (which can be modified by users of the API!)
    # and in part on the contents of the code string itself.

    def _compute_flags(self):
        # take a census of the unique opcodes used.
        opcodes = set(op for op, arg in self.code if isopcode(op))

        # calculate CO_OPTIMIZED based on opcode usage.
        optimized = (STORE_NAME not in opcodes and
                     LOAD_NAME not in opcodes and
                     DELETE_NAME not in opcodes)

        # note if a yield is used.
        generator = (YIELD_VALUE in opcodes)

        # CO_NOFREE means, no opcodes that refer to "free" vars
        nofree = not (opcodes.intersection(hasfree))

        flags = 0
        if optimized: flags |= CO_OPTIMIZED
        if self.newlocals: flags |= CO_NEWLOCALS
        if self.varargs: flags |= CO_VARARGS
        if self.varkwargs: flags |= CO_VARKEYWORDS
        if generator: flags |= CO_GENERATOR
        if nofree: flags |= CO_NOFREE

        # Something we cannot calculate from opcode usage: is this a
        # coroutine? Just test the original flag value.

        if self.coflags & CO_COROUTINE :
            flags |= CO_COROUTINE
            if generator :
                flags |= CO_ITERABLE_COROUTINE

        return flags

    def _compute_stacksize(self):
        '''
        Given this object's code list, compute its maximal stack usage.
        This is done by scanning the code, and computing for each opcode
        the stack state at the opcode.

        '''

        # get local access to code, save some attribute lookups later
        code = self.code

        # A mapping from labels to their positions in the code list
        label_pos = { op : pos
                        for pos, (op, arg) in enumerate(code)
                        if isinstance(op, Label)
                    }

        # sf_targets are the targets of SETUP_FINALLY opcodes. They are
        # recorded because they have special stack behaviour. If an exception
        # was raised in the block pushed by a SETUP_FINALLY opcode, the block
        # is popped and 3 objects are pushed. On return or continue, the
        # block is popped and 2 objects are pushed. If nothing happened, the
        # block is popped by a POP_BLOCK opcode and 1 object is pushed by a
        # (LOAD_CONST, None) operation.
        #
        # In Python 3, the targets of SETUP_WITH have similar behavior,
        # complicated by the fact that they also have an __exit__ method
        # stacked and what it returns determines what they pop. So their
        # stack depth is one greater, a fact we are going to ignore for the
        # time being :-/
        #
        # Our solution is to record the stack state of SETUP_FINALLY targets
        # as having 3 objects pushed, which is the maximum. However, to make
        # stack recording consistent, the get_next_stacks function will always
        # yield the stack state of the target as if 1 object was pushed, but
        # this will be corrected in the actual stack recording.

        sf_targets = set( label_pos[arg]
                          for op, arg in code
                          if op == SETUP_FINALLY or op == SETUP_WITH
                        )

        # What we compute - for each opcode, its stack state, as an n-tuple.
        # n is the number of blocks pushed. For each block, we record the number
        # of objects pushed.
        stacks = [None] * len(code)

        def get_next_stacks(pos, curstack):
            """
            Get a code position and the stack state before the operation
            was done, and yield pairs (pos, curstack) for the next positions
            to be explored - those are the positions to which you can get
            from the given (pos, curstack).

            If the given position was already explored, nothing will be yielded.
            """
            op, arg = code[pos]

            if isinstance(op, Label):
                # We should check if we already reached a node only if it is
                # a label.

                if pos in sf_targets:
                    # Adjust a SETUP_FINALLY from 1 to 3 stack entries.
                    curstack = curstack[:-1] + (curstack[-1] + 2,)

                if stacks[pos] is None:
                    stacks[pos] = curstack
                else:
                    if stacks[pos] != curstack:
                        raise ValueError("Inconsistent code")
                    return

            def newstack(n):
                # Return a new stack, modified by adding n elements to the last
                # block
                if curstack[-1] + n < 0:
                    raise ValueError("Popped a non-existing element")
                return curstack[:-1] + (curstack[-1]+n,)

            if not isopcode(op):
                # label or SetLineno - just continue to next line
                yield pos+1, curstack

            elif op in ( RETURN_VALUE, RAISE_VARARGS ):
                # No place in particular to continue to
                pass

            elif op in (JUMP_FORWARD, JUMP_ABSOLUTE):
                # One possibility for a jump
                yield label_pos[arg], curstack

            elif op in (POP_JUMP_IF_FALSE, POP_JUMP_IF_TRUE):
                # Two possibilities for a jump
                yield label_pos[arg], newstack(-1)
                yield pos+1, newstack(-1)

            elif op in (JUMP_IF_TRUE_OR_POP, JUMP_IF_FALSE_OR_POP):
                # Two possibilities for a jump
                yield label_pos[arg], curstack
                yield pos+1, newstack(-1)

            elif op == FOR_ITER:
                # FOR_ITER pushes next(TOS) on success, and pops TOS and jumps
                # on failure
                yield label_pos[arg], newstack(-1)
                yield pos+1, newstack(1)

            elif op == BREAK_LOOP:
                # BREAK_LOOP goes to the end of a loop and pops a block
                # but like RETURN_VALUE we have no instruction position
                # to give. For now treat like RETURN_VALUE
                pass

            elif op == CONTINUE_LOOP:
                # CONTINUE_LOOP jumps to the beginning of a loop which should
                # already have been discovered. It does not change the stack
                # state nor does it create or pop a block.
                #yield label_pos[arg], curstack
                #yield label_pos[arg], curstack[:-1]
                pass

            elif op == SETUP_LOOP:
                # We continue with a new block.
                # On break, we jump to the label and return to current stack
                # state.
                yield label_pos[arg], curstack
                yield pos+1, curstack + (0,)

            elif op == SETUP_EXCEPT:
                # We continue with a new block.
                # On exception, we jump to the label with 3 extra objects on
                # stack
                yield label_pos[arg], newstack(3)
                yield pos+1, curstack + (0,)

            elif op == SETUP_FINALLY or op == SETUP_WITH :
                # We continue with a new block.
                # On exception, we jump to the label with 3 extra objects on
                # stack, but to keep stack recording consistent, we behave as
                # if we add only 1 object. Extra 2 will be added to the actual
                # recording.
                yield label_pos[arg], newstack(1)
                yield pos+1, curstack + ( int(op == SETUP_WITH) ,)

            elif op == POP_BLOCK:
                # Just pop the block
                yield pos+1, curstack[:-1]

            elif op == END_FINALLY :
                # Since stack recording of SETUP_FINALLY targets is of 3 pushed
                # objects (as when an exception is raised), we pop 3 objects.
                yield pos+1, newstack(-3)

            elif op == _WITH_CLEANUP_OPCODE:
                # Since WITH_CLEANUP[_START] is always found after SETUP_FINALLY
                # targets, and the stack recording is that of a raised
                # exception, we can simply pop 1 object and let END_FINALLY
                # pop the remaining 3.
                yield pos+1, newstack(-1)

            else:
                # nothing special, use the CPython value
                yield pos+1, newstack( stack_effect( op, arg ) )


        # Now comes the calculation: open_positions holds positions which are
        # yet to be explored. In each step we take one open position, and
        # explore it by appending the positions to which it can go, to
        # open_positions. On the way, we update maxsize.
        #
        # open_positions is a list of tuples: (pos, stack state)
        #
        # Sneaky Python coding trick here. get_next_stacks() is a generator,
        # it contains yield statements. So when we call get_next_stacks()
        # what is returned is an iterator. However, the yield statements in
        # get_next_stacks() are not in a loop as usual; rather it is
        # straight-line code that will execute 0, 1 or 2 yields depending on
        # the Opcode at pos.
        #
        # the list.extend() method takes an iterator and exhausts it, adding
        # all yielded values to the list. Hence the statement
        #
        #   open_positions.extend(get_next_stacks(pos,curstack))
        #
        # appends 0, 1 or 2 tuples (pos, stack_state) to open_positions.

        maxsize = 0
        open_positions = [(0, (0,))]
        while open_positions:
            pos, curstack = open_positions.pop()
            maxsize = max(maxsize, sum(curstack))
            open_positions.extend(get_next_stacks(pos, curstack))

        return maxsize

    def to_code(self):
        """
        Assemble a Python code object from this Code object.
        """
        co_argcount = len(self.args) - self.varargs - self.varkwargs - self.kwonlyargcount
        co_kwonlyargcount = self.kwonlyargcount
        co_stacksize = self._compute_stacksize()
        co_flags = self._compute_flags()

        co_consts = [self.docstring]
        co_names = []
        co_varnames = list(self.args)

        co_freevars = tuple(self.freevars)

        # We find all cellvars beforehand, for two reasons:
        # 1. We need the number of them to construct the numeric argument
        #    for ops in "hasfree".
        # 2. We need to put arguments which are cell vars in the beginning
        #    of co_cellvars
        cellvars = set( arg for op, arg in self.code
                        if isopcode(op)
                        and op in hasfree
                        and arg not in co_freevars
                    )
        co_cellvars = [x for x in self.args if x in cellvars]

        def index(seq, item, eq=operator.eq, can_append=True):
            """
            Find the index of item in a sequence and return it.
            If it is not found in the sequence, and can_append is True,
            it is appended to the sequence.

            eq is the equality operator to use.
            """
            for i, x in enumerate(seq):
                if eq(x, item):
                    return i
            else:
                if can_append:
                    seq.append(item)
                    return len(seq) - 1
                else:
                    raise IndexError("Item not found")

        # List of tuples (pos, label) to be filled later
        jumps = []
        # A mapping from a label to its position
        label_pos = {}
        # Last SetLineno
        lastlineno = self.firstlineno
        lastlinepos = 0

        assert(False) # no array available XXX
        co_code = array('B')
        co_lnotab = array('B')
        for i, (op, arg) in enumerate(self.code):
            if isinstance(op, Label):
                label_pos[op] = len(co_code)

            elif isinstance( op, SetLinenoType ) :
                incr_lineno = arg - lastlineno
                incr_pos = len(co_code) - lastlinepos
                lastlineno = arg
                lastlinepos = len(co_code)

                # See pedantic comments about the encoding of co_lnotab and
                # values over 255 in the prolog to from_code().

                if incr_lineno == 0 and incr_pos == 0:
                    co_lnotab.append(0)
                    co_lnotab.append(0)
                else:
                    while incr_pos > 255:
                        co_lnotab.append(255)
                        co_lnotab.append(0)
                        incr_pos -= 255
                    while incr_lineno > 255:
                        co_lnotab.append(incr_pos)
                        co_lnotab.append(255)
                        incr_pos = 0
                        incr_lineno -= 255
                    if incr_pos or incr_lineno:
                        co_lnotab.append(incr_pos)
                        co_lnotab.append(incr_lineno)

            elif op == opcode.EXTENDED_ARG:
                raise ValueError("EXTENDED_ARG not supported in Code objects")

            elif not op in hasarg:
                co_code.append(op)

            else:
                if op in hasconst:
                    # op takes a constant. Check for the special case of the
                    # constant value being a Code object. If that is so, then
                    # check that there are at least 2 more ops in the
                    # CodeList and the next+1 op is MAKE_FUNCTION/_CLOSURE.
                    # This special case is assured by the from_code() logic,
                    # but if the user has modified the CodeList, we want to
                    # catch the error now.

                    if isinstance(arg, Code) :
                        if i < len(self.code)-2 \
                           and self.code[i+2][0] in hascode :
                            arg = arg.to_code()
                        else :
                            raise ValueError('Invalid opcode sequence for Code enclosure')
                    # locate, or stow, the argument value in the code object
                    # constants list and keep its index.
                    arg = index(co_consts, arg, operator.is_)
                elif op in hasname:
                    arg = index(co_names, arg)
                elif op in hasjump:
                    # arg will be filled later
                    jumps.append((len(co_code), arg))
                    arg = 0
                elif op in haslocal:
                    arg = index(co_varnames, arg)
                elif op in hascompare:
                    arg = index(cmp_op, arg, can_append=False)
                elif op in hasfree:
                    try:
                        arg = index(co_freevars, arg, can_append=False) \
                              + len(cellvars)
                    except IndexError:
                        arg = index(co_cellvars, arg)
                else:
                    # arg is ok
                    pass

                if arg > 0xFFFF:
                    co_code.append(opcode.EXTENDED_ARG)
                    co_code.append((arg >> 16) & 0xFF)
                    co_code.append((arg >> 24) & 0xFF)
                co_code.append(op)
                co_code.append(arg & 0xFF)
                co_code.append((arg >> 8) & 0xFF)

        for pos, label in jumps:
            jump = label_pos[label]
            if co_code[pos] in hasjrel:
                jump -= pos+3
            if jump > 0xFFFF:
                raise NotImplementedError("Extended jumps not implemented")
            co_code[pos+1] = jump & 0xFF
            co_code[pos+2] = (jump >> 8) & 0xFF

        co_code = co_code.tostring()
        co_lnotab = co_lnotab.tostring()

        co_consts = tuple(co_consts)
        co_names = tuple(co_names)
        co_varnames = tuple(co_varnames)
        co_nlocals = len(co_varnames)
        co_cellvars = tuple(co_cellvars)

        return types.CodeType(co_argcount, co_kwonlyargcount, co_nlocals, co_stacksize, co_flags,
                              co_code,
                              co_consts, co_names, co_varnames,
                              self.filename, self.name, self.firstlineno, co_lnotab,
                              co_freevars, co_cellvars)
#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

# END OF Byteplay external API. All the following are for test only.

#-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-

# XXX END byteplay3.py

# XXX BEGIN boa/code/pyop.py
print("loading boa/code/pyop.py")

# XXX IMPORTANT: create class pyop to group elements (since we dont have import system anymore...)

# the following are python opcodes taken from the `opcode` module
# these have been constantized for easier access
# these are the opcodes used by python


# not to be confused with opcodes from neo.VM.OpCode,
# which are the opcodes for the neo vm

class pyop:
    POP_TOP = 1
    ROT_TWO = 2
    ROT_THREE = 3
    DUP_TOP = 4
    DUP_TOP_TWO = 5

    NOP = 9
    UNARY_POSITIVE = 10
    UNARY_NEGATIVE = 11
    UNARY_NOT = 12

    UNARY_INVERT = 15

    BINARY_MATRIX_MULTIPLY = 16
    INPLACE_MATRIX_MULTIPLY = 17

    BINARY_POWER = 19
    BINARY_MULTIPLY = 20

    BINARY_MODULO = 22
    BINARY_ADD = 23
    BINARY_SUBTRACT = 24
    BINARY_SUBSCR = 25
    BINARY_FLOOR_DIVIDE = 26
    BINARY_TRUE_DIVIDE = 27
    INPLACE_FLOOR_DIVIDE = 28
    INPLACE_TRUE_DIVIDE = 29

    GET_AITER = 50
    GET_ANEXT = 51
    BEFORE_ASYNC_WITH = 52

    INPLACE_ADD = 55
    INPLACE_SUBTRACT = 56
    INPLACE_MULTIPLY = 57

    INPLACE_MODULO = 59
    STORE_SUBSCR = 60
    DELETE_SUBSCR = 61
    BINARY_LSHIFT = 62
    BINARY_RSHIFT = 63
    BINARY_AND = 64
    BINARY_XOR = 65
    BINARY_OR = 66
    INPLACE_POWER = 67
    GET_ITER = 68
    GET_YIELD_FROM_ITER = 69

    PRINT_EXPR = 70
    LOAD_BUILD_CLASS = 71
    YIELD_FROM = 72
    GET_AWAITABLE = 73

    INPLACE_LSHIFT = 75
    INPLACE_RSHIFT = 76
    INPLACE_AND = 77
    INPLACE_XOR = 78
    INPLACE_OR = 79
    BREAK_LOOP = 80
    WITH_CLEANUP_START = 81
    WITH_CLEANUP_FINISH = 82

    RETURN_VALUE = 83
    IMPORT_STAR = 84

    YIELD_VALUE = 86
    POP_BLOCK = 87
    END_FINALLY = 88
    POP_EXCEPT = 89


    HAVE_ARGUMENT = 90              # Opcodes from here have an argument:

    STORE_NAME = 90       # Index in name list
    DELETE_NAME = 91      # ""
    UNPACK_SEQUENCE = 92   # Number of tuple items

    FOR_ITER = 93  # jrel op

    UNPACK_EX = 94
    STORE_ATTR = 95       # Index in name list
    DELETE_ATTR = 96      # ""
    STORE_GLOBAL = 97     # ""
    DELETE_GLOBAL = 98    # ""
    LOAD_CONST = 100       # Index in const list

    # hasconst.append(100

    LOAD_NAME = 101       # Index in name list
    BUILD_TUPLE = 102      # Number of tuple items
    BUILD_LIST = 103       # Number of list items
    BUILD_SET = 104        # Number of set items
    BUILD_MAP = 105        # Number of dict entries (upto 255
    LOAD_ATTR = 106       # Index in name list
    COMPARE_OP = 107       # Comparison operator

    IMPORT_NAME = 108     # Index in name list
    IMPORT_FROM = 109     # Index in name list

    JUMP_FORWARD = 110    # Number of bytes to skip
    JUMP_IF_FALSE_OR_POP = 111  # Target byte offset from beginning of code
    JUMP_IF_TRUE_OR_POP = 112  # "jabs op"
    JUMP_ABSOLUTE = 113        # "jabs op"
    POP_JUMP_IF_FALSE = 114    # "jabs op"
    POP_JUMP_IF_TRUE = 115     # "jabs op"

    LOAD_GLOBAL = 116     # Index in name list

    CONTINUE_LOOP = 119   # Target address jrel
    SETUP_LOOP = 120      # Distance to target address jrel
    SETUP_EXCEPT = 121    # "jrel"
    SETUP_FINALLY = 122   # "jrel"

    LOAD_FAST = 124        # Local variable number
    STORE_FAST = 125       # Local variable number
    DELETE_FAST = 126      # Local variable number

    RAISE_VARARGS = 130    # Number of raise arguments (1, 2, or 3
    CALL_FUNCTION = 131    # #args + (#kwargs << 8


    MAKE_FUNCTION = 132    # Number of args with default values
    BUILD_SLICE = 133      # Number of items
    MAKE_CLOSURE = 134
    LOAD_CLOSURE = 135

    LOAD_DEREF = 136

    STORE_DEREF = 137

    DELETE_DEREF = 138

    CALL_FUNCTION_VAR = 140     # #args + (#kwargs << 8
    CALL_FUNCTION_KW = 141      # #args + (#kwargs << 8
    CALL_FUNCTION_VAR_KW = 142  # #args + (#kwargs << 8

    SETUP_WITH = 143

    LIST_APPEND = 145
    SET_ADD = 146
    MAP_ADD = 147

    LOAD_CLASSDEREF = 148

    SETUP_ASYNC_WITH = 154

    EXTENDED_ARG = 144

    BUILD_LIST_UNPACK = 149
    BUILD_MAP_UNPACK = 150
    BUILD_MAP_UNPACK_WITH_CALL = 151
    BUILD_TUPLE_UNPACK = 152
    BUILD_SET_UNPACK = 153


    # boa custom ops

    FROMALTSTACK = 241
    DROP = 242

    BR_S = 243

    SETITEM = 244

    LD_ELEMENT = 245

    XSWAP = 246
    ROLL = 247

    DROP_BODY = 248

# XXX END boa/code/pyop.py

# XXX BEGIN boa/code/line.py
print("loading boa/code/line.py")

#from boa.code.byteplay3 import *

#from boa.code import pyop


class Line():

    """

    """
    items = None

    def __init__(self, item_list):
        self.items = item_list

    @property
    def is_import(self):
        """

        :return:
        """
        for i, (op, arg) in enumerate(self.items):
            if op in [pyop.IMPORT_NAME, pyop.IMPORT_FROM, pyop.IMPORT_STAR]: # XXX
            #if op in [IMPORT_NAME, IMPORT_FROM, IMPORT_STAR]:
                return True
        return False

    @property
    def is_definition(self):
        """

        :return:
        """
        return len(self.items) == 3 and self.items[1][0] == pyop.LOAD_CONST and self.items[2][0] == pyop.STORE_NAME
#        return False

    @property
    def is_docstring(self):
        """
        returns whether a line is a docstring

        :return: whether a line is a documentation string
        :rtype: bool

        """
        for item in self.items:
            if item[0] == pyop.STORE_NAME and item[1] == '__doc__': # XXX
            #if item[0] == STORE_NAME and item[1] == '__doc__':
                return True
        return False

    @property
    def is_method(self):
        """

        :return:
        """
        for i, (op, arg) in enumerate(self.items):
            if op == pyop.MAKE_FUNCTION: # XXX
            #if op == MAKE_FUNCTION:
                return True
        return False

    @property
    def is_class(self):
        """

        :return:
        """
        for i, (op, arg) in enumerate(self.items):
            if op == pyop.LOAD_BUILD_CLASS: # XXX
            #if op == LOAD_BUILD_CLASS:
                return True
        return False

    @property
    def code_object(self):
        """

        :return:
        """
        for i, (op, arg) in enumerate(self.items):
            if type(arg) is Code:
                return arg
        return None

    @property
    def is_action_registration(self):
        """

        :return:
        """
        for i, (op, arg) in enumerate(self.items):
            if arg == 'RegisterAction':
                return True

    @property
    def is_smart_contract_appcall_registration(self):
        """

        :return:
        """
        for i, (op, arg) in enumerate(self.items):
            if arg == 'RegisterAppCall':
                return True

# XXX END boa/code/line.py

# XXX BEGIN boa/blockchain/vm/VMOp.py
print("loading boa/blockchain/vm/VMOp.py")

#import sys
#import importlib
#import binascii

# XXX IMPORTANT: Create class VMOp to group operations (since we don't have import system anymore...)

class VMOp:
    #  Constants
    PUSH0 = b'\x00'  # An empty array of bytes is pushed onto the stack.
    PUSHF = PUSH0
    PUSHBYTES1 = b'\x01'  # b'\x01-b'\x4B The next opcode bytes is data to be pushed onto the stack
    PUSHBYTES75 = b'\x4B'
    PUSHDATA1 = b'\x4C'  # The next byte contains the number of bytes to be pushed onto the stack.
    PUSHDATA2 = b'\x4D'  # The next two bytes contain the number of bytes to be pushed onto the stack.
    PUSHDATA4 = b'\x4E'  # The next four bytes contain the number of bytes to be pushed onto the stack.
    PUSHM1 = b'\x4F'  # The number -1 is pushed onto the stack.
    PUSH1 = b'\x51'  # The number 1 is pushed onto the stack.
    PUSHT = PUSH1
    PUSH2 = b'\x52'  # The number 2 is pushed onto the stack.
    PUSH3 = b'\x53'  # The number 3 is pushed onto the stack.
    PUSH4 = b'\x54'  # The number 4 is pushed onto the stack.
    PUSH5 = b'\x55'  # The number 5 is pushed onto the stack.
    PUSH6 = b'\x56'  # The number 6 is pushed onto the stack.
    PUSH7 = b'\x57'  # The number 7 is pushed onto the stack.
    PUSH8 = b'\x58'  # The number 8 is pushed onto the stack.
    PUSH9 = b'\x59'  # The number 9 is pushed onto the stack.
    PUSH10 = b'\x5A'  # The number 10 is pushed onto the stack.
    PUSH11 = b'\x5B'  # The number 11 is pushed onto the stack.
    PUSH12 = b'\x5C'  # The number 12 is pushed onto the stack.
    PUSH13 = b'\x5D'  # The number 13 is pushed onto the stack.
    PUSH14 = b'\x5E'  # The number 14 is pushed onto the stack.
    PUSH15 = b'\x5F'  # The number 15 is pushed onto the stack.
    PUSH16 = b'\x60'  # The number 16 is pushed onto the stack.


    #  Flow control
    NOP = b'\x61'  # Does nothing.
    JMP = b'\x62'
    JMPIF = b'\x63'
    JMPIFNOT = b'\x64'
    CALL = b'\x65'
    RET = b'\x66'
    APPCALL = b'\x67'
    SYSCALL = b'\x68'
    TAILCALL = b'\x69'


    #  Stack
    DUPFROMALTSTACK = b'\x6A'
    TOALTSTACK = b'\x6B'  # Puts the input onto the top of the alt stack. Removes it from the main stack.
    FROMALTSTACK = b'\x6C'  # Puts the input onto the top of the main stack. Removes it from the alt stack.
    XDROP = b'\x6D'
    XSWAP = b'\x72'
    XTUCK = b'\x73'
    DEPTH = b'\x74'  # Puts the number of stack items onto the stack.
    DROP = b'\x75'  # Removes the top stack item.
    DUP = b'\x76'  # Duplicates the top stack item.
    NIP = b'\x77'  # Removes the second-to-top stack item.
    OVER = b'\x78'  # Copies the second-to-top stack item to the top.
    PICK = b'\x79'  # The item n back in the stack is copied to the top.
    ROLL = b'\x7A'  # The item n back in the stack is moved to the top.
    ROT = b'\x7B'  # The top three items on the stack are rotated to the left.
    SWAP = b'\x7C'  # The top two items on the stack are swapped.
    TUCK = b'\x7D'  # The item at the top of the stack is copied and inserted before the second-to-top item.


    #  Splice
    CAT = b'\x7E'  # Concatenates two strings.
    SUBSTR = b'\x7F'  # Returns a section of a string.
    LEFT = b'\x80'  # Keeps only characters left of the specified point in a string.
    RIGHT = b'\x81'  # Keeps only characters right of the specified point in a string.
    SIZE = b'\x82'  # Returns the length of the input string.


    #  Bitwise logic
    INVERT = b'\x83'  # Flips all of the bits in the input.
    AND = b'\x84'  # Boolean and between each bit in the inputs.
    OR = b'\x85'  # Boolean or between each bit in the inputs.
    XOR = b'\x86'  # Boolean exclusive or between each bit in the inputs.
    EQUAL = b'\x87'  # Returns 1 if the inputs are exactly equal' 0 otherwise.
    # OP_EQUALVERIFY = b'\x88' #  Same as OP_EQUAL' but runs OP_VERIFY afterward.
    # OP_RESERVED1 = b'\x89' #  Transaction is invalid unless occuring in an unexecuted OP_IF branch
    # OP_RESERVED2 = b'\x8A' #  Transaction is invalid unless occuring in an unexecuted OP_IF branch

    #  Arithmetic
    #  Note: Arithmetic inputs are limited to signed 32-bit integers' but may overflow their output.
    INC = b'\x8B'  # 1 is added to the input.
    DEC = b'\x8C'  # 1 is subtracted from the input.
    SIGN = b'\x8D'
    NEGATE = b'\x8F'  # The sign of the input is flipped.
    ABS = b'\x90'  # The input is made positive.
    NOT = b'\x91'  # If the input is 0 or 1' it is flipped. Otherwise the output will be 0.
    NZ = b'\x92'  # Returns 0 if the input is 0. 1 otherwise.
    ADD = b'\x93'  # a is added to b.
    SUB = b'\x94'  # b is subtracted from a.
    MUL = b'\x95'  # a is multiplied by b.
    DIV = b'\x96'  # a is divided by b.
    MOD = b'\x97'  # Returns the remainder after dividing a by b.
    SHL = b'\x98'  # Shifts a left b bits' preserving sign.
    SHR = b'\x99'  # Shifts a right b bits' preserving sign.
    BOOLAND = b'\x9A'  # If both a and b are not 0' the output is 1. Otherwise 0.
    BOOLOR = b'\x9B'  # If a or b is not 0' the output is 1. Otherwise 0.
    NUMEQUAL = b'\x9C'  # Returns 1 if the numbers are equal' 0 otherwise.
    NUMNOTEQUAL = b'\x9E'  # Returns 1 if the numbers are not equal' 0 otherwise.
    LT = b'\x9F'  # Returns 1 if a is less than b' 0 otherwise.
    GT = b'\xA0'  # Returns 1 if a is greater than b' 0 otherwise.
    LTE = b'\xA1'  # Returns 1 if a is less than or equal to b' 0 otherwise.
    GTE = b'\xA2'  # Returns 1 if a is greater than or equal to b' 0 otherwise.
    MIN = b'\xA3'  # Returns the smaller of a and b.
    MAX = b'\xA4'  # Returns the larger of a and b.
    WITHIN = b'\xA5'  # Returns 1 if x is within the specified range (left-inclusive)' 0 otherwise.

    #  Crypto
    # RIPEMD160 = b'\xA6' #  The input is hashed using RIPEMD-160.
    SHA1 = b'\xA7'  # The input is hashed using SHA-1.
    SHA256 = b'\xA8'  # The input is hashed using SHA-256.
    HASH160 = b'\xA9'
    HASH256 = b'\xAA'
    CHECKSIG = b'\xAC'
    CHECKMULTISIG = b'\xAE'


    #  Array
    ARRAYSIZE = b'\xC0'
    PACK = b'\xC1'
    UNPACK = b'\xC2'
    PICKITEM = b'\xC3'
    SETITEM = b'\xC4'
    NEWARRAY = b'\xC5'  # 用作引用類型
    NEWSTRUCT = b'\xC6'  # 用作值類型

# the following is a convienience method
# for a human readable version of the ops

#module = importlib.import_module('boa.blockchain.vm.VMOp')
#items = dir(sys.modules[__name__])

#def ToName(op):
#    """
#
#    :param op:
#    :return:
#    """
#    if isinstance(op, bytes):
#        op = int.from_bytes(op, 'little')
#
#    for item in items:
#        n = getattr(module, item)
#
#        try:
#            nn = int(binascii.hexlify(n))
#
#            if op == nn:
#                return item
#        except Exception as e:
#            pass
#
#        try:
#            nn2 = int.from_bytes(n, 'little')
#            if op == nn2:
#                return item
#        except Exception as e:
#            pass
#
#    return None

# XXX END boa/blockchain/vm/VMOp.py

# XXX BEGIN boa/code/pytoken.py
print("loading boa/code/pytoken.py")

#from boa.code import pyop
#from boa.code.byteplay3 import Label, isopcode, haslocal, Code
#from opcode import opname
#from boa.blockchain.vm import VMOp

class PyToken():

    """

    """
    py_op = None

    args = None

    line_no = None

    addr = None

    tokenizer = None

    jump_label = None

    array_processed = False

    array_item = None

    # method calling things

    func_processed = False

    func_params = None

    func_name = None
    func_type = None

    script_hash_token = None

    @property
    def op_name(self):
        """

        :return:
        """
        if type(self.py_op) is int:
            return opname[self.py_op]
        elif type(self.py_op) is Label:
            return 'Label %s ' % self.py_op
        return self.py_op

    @property
    def is_op(self):
        """

        :return:
        """
        return isopcode(self.py_op)

    @property
    def is_local(self):
        """

        :return:
        """
        return haslocal(self.py_op)

    @property
    def arg_s(self):
        """

        :return:
        """
        if self.args:
            return str(self.args)
        return ''

    def __init__(self, op, lineno, index=None, args=None, array_item=None):

        self.py_op = op

        self.args = args

        self.line_no = lineno

        self.addr = index

        self.array_item = array_item

    def __str__(self):
        arg = ''

        if self.args:
            if type(self.args) is Label:
                arg = str(self.args)
            else:
                arg = self.args
            return '%s      %s   %s  --> %s ' % (self.line_no, self.addr, self.op_name, arg)
        return '%s      %s   %s' % (self.line_no, self.addr, self.op_name)

    def to_vm(self, tokenizer, prev_token=None):
        """

        :param tokenizer:
        :param prev_token:
        :return:
        """
        self.tokenizer = tokenizer
        token = None

        if self.is_op:

            op = self.py_op

            if op == pyop.NOP:
                token = tokenizer.convert1(VMOp.NOP, self)

            elif op == pyop.RETURN_VALUE:
                token = tokenizer.convert1(VMOp.RET, self)

            # control flow
            elif op == pyop.BR_S:
                token = tokenizer.convert1(VMOp.JMP, self, data=self.args)

            elif op == pyop.JUMP_FORWARD:
                token = tokenizer.convert1(VMOp.JMP, self, data=bytearray(2))

            elif op == pyop.JUMP_ABSOLUTE:
                token = tokenizer.convert1(VMOp.JMP, self, data=bytearray(2))

            elif op == pyop.POP_JUMP_IF_FALSE:
                token = tokenizer.convert1(
                    VMOp.JMPIFNOT, self, data=bytearray(2))

            elif op == pyop.POP_JUMP_IF_TRUE:
                token = tokenizer.convert1(VMOp.JMPIF, self, data=bytearray(2))

            # loops
            elif op == pyop.SETUP_LOOP:
                token = tokenizer.convert1(VMOp.NOP, self)

            elif op == pyop.BREAK_LOOP:
                token = tokenizer.convert1(VMOp.JMP, self, data=bytearray(2))

            elif op == pyop.FOR_ITER:
                token = tokenizer.convert1(VMOp.NOP, self)

#            elif op == pyop.GET_ITER:
#                token = tokenizer.convert1(VMOp.NOP, self)

            elif op == pyop.POP_BLOCK:
                token = tokenizer.convert1(VMOp.NOP, self)

            elif op == pyop.FROMALTSTACK:
                token = tokenizer.convert1(VMOp.FROMALTSTACK, self)
            elif op == pyop.DROP:
                token = tokenizer.convert1(VMOp.DROP, self)
            elif op == pyop.XSWAP:
                token = tokenizer.convert1(VMOp.XSWAP, self)
            elif op == pyop.ROLL:
                token = tokenizer.convert1(VMOp.ROLL, self)

            # loading constants ( ie 1, 2 etc)
            elif op == pyop.LOAD_CONST:

                if type(self.args) is int:
                    token = tokenizer.convert_push_integer(self.args, self)
                elif type(self.args) is str:
                    str_bytes = self.args.encode('utf-8')
                    self.args = str_bytes
                    token = tokenizer.convert_push_data(self.args, self)
                elif type(self.args) is bytes:
                    token = tokenizer.convert_push_data(self.args, self)
                elif type(self.args) is bytearray:
                    token = tokenizer.convert_push_data(bytes(self.args), self)
                elif type(self.args) is bool:
                    token = tokenizer.convert_push_integer(self.args)
                elif type(self.args) == type(None):
                    token = tokenizer.convert_push_data(bytearray(0))
                elif type(self.args) == Code:
                    pass
                else:

                    raise Exception("Could not load type %s for item %s " % (
                        type(self.args), self.args))

            # storing / loading local variables
            elif op in [pyop.STORE_FAST, pyop.STORE_NAME]:
                token = tokenizer.convert_store_local(self)

            elif op in [pyop.LOAD_FAST, pyop.LOAD_NAME, pyop.LOAD_GLOBAL]:
                token = tokenizer.convert_load_local(self)

            # unary ops

#            elif op == pyop.UNARY_INVERT:
#                token = tokenizer.convert1(VMOp.INVERT, self)

            elif op == pyop.UNARY_NEGATIVE:
                token = tokenizer.convert1(VMOp.NEGATE, self)

            elif op == pyop.UNARY_NOT:
                token = tokenizer.convert1(VMOp.NOT, self)

#            elif op == pyop.UNARY_POSITIVE:
                # hmmm
#                token = tokenizer.convert1(VMOp.ABS, self)
#                pass

            # math
            elif op in [pyop.BINARY_ADD, pyop.INPLACE_ADD]:

                # we can't tell by looking up the last token what type of item it was
                # will need to figure out a different way of concatting strings
                #                if prev_token and type(prev_token.args) is str:
                #                    token = tokenizer.convert1(VMOp.CAT, self)
                #                else:
                token = tokenizer.convert1(VMOp.ADD, self)

            elif op in [pyop.BINARY_SUBTRACT, pyop.INPLACE_SUBTRACT]:
                token = tokenizer.convert1(VMOp.SUB, self)

            elif op in [pyop.BINARY_MULTIPLY, pyop.INPLACE_MULTIPLY]:
                token = tokenizer.convert1(VMOp.MUL, self)

            elif op in [pyop.BINARY_FLOOR_DIVIDE, pyop.BINARY_TRUE_DIVIDE, pyop.INPLACE_FLOOR_DIVIDE, pyop.INPLACE_TRUE_DIVIDE]:
                token = tokenizer.convert1(VMOp.DIV, self)

            elif op in [pyop.BINARY_MODULO, pyop.INPLACE_MODULO]:
                token = tokenizer.convert1(VMOp.MOD, self)

            elif op == [pyop.BINARY_OR, pyop.INPLACE_OR]:
                token = tokenizer.convert1(VMOp.BOOLOR, self)

            elif op == [pyop.BINARY_AND, pyop.INPLACE_AND]:
                token = tokenizer.convert1(VMOp.BOOLAND, self)

            elif op == [pyop.BINARY_XOR, pyop.INPLACE_XOR]:
                token = tokenizer.convert1(VMOp.XOR, self)

            elif op in [pyop.BINARY_LSHIFT, pyop.INPLACE_LSHIFT]:
                token = tokenizer.convert1(VMOp.SHL, self)

            elif op in [pyop.BINARY_RSHIFT, pyop.INPLACE_RSHIFT]:
                token = tokenizer.convert1(VMOp.SHR, self)

            # compare

            elif op == pyop.COMPARE_OP:

                if self.args == '>':
                    token = tokenizer.convert1(VMOp.GT, self)
                elif self.args == '>=':
                    token = tokenizer.convert1(VMOp.GTE, self)
                elif self.args == '<':
                    token = tokenizer.convert1(VMOp.LT, self)
                elif self.args == '<=':
                    token = tokenizer.convert1(VMOp.LTE, self)
                elif self.args == '==':
                    token = tokenizer.convert1(VMOp.NUMEQUAL, self)
                elif self.args == 'is':
                    token = tokenizer.convert1(VMOp.EQUAL, self)
                elif self.args == '!=':
                    token = tokenizer.convert1(VMOp.NUMNOTEQUAL, self)

            # arrays
            elif op == pyop.BUILD_LIST:
                token = tokenizer.convert_new_array(VMOp.NEWARRAY, self)
            elif op == pyop.SETITEM:
                token = tokenizer.convert_set_element(self, self.args)
#                token = tokenizer.convert1(VMOp.SETITEM,self, data=self.args)
            elif op == pyop.STORE_SUBSCR:
                # this wont occur because this op is preprocessed into a SETITEM op
                pass
            elif op == pyop.BINARY_SUBSCR:
                token = tokenizer.convert1(VMOp.PICKITEM, self)

            elif op == pyop.BUILD_SLICE:
                token = tokenizer.convert_build_slice(self)

            # strings

            elif op == pyop.CALL_FUNCTION:

                token = tokenizer.convert_method_call(self)


#            else:
#                print("OP NOT CONVERTED %s " % op)

        return token

# XXX END boa/code/pytoken.py

# XXX BEGIN boa/blockchain/vm/BigInteger.py
print("loading boa/blockchain/vm/BigInteger.py")


class BigInteger(int):

    @staticmethod
    def FromBytes(data, signed=False):
        """
        Convert a bytearray into a BigInteger object

        :param data: a bytearray representing an integer
        :type data: bytearray

        :param signed: whether or not the bytearray is signed
        :type signed: bool

        :return: a BigInteger object
        :rtype: ``boa.blockchain.vm.BigInteger``

        """
        return BigInteger(int.from_bytes(data, 'little', signed=signed))

    def Equals(self, other):
        """
        Compare two BigInteger objects

        :param other: the BigInteger to compare this one with
        :type other: BigInteger

        :return: whether the two items are equal
        :rtype: bool

        """
        return super(BigInteger, self).__eq__(other)

    def ToByteArray(self, signed=True):
        """

        converts a big integer object into a bytearray

        :param signed: whether or not it should be signed
        :type signed: bool

        :return: a bytearray of representing the BigInteger
        :rtype: bytearray

        """

        if self < 0:
            try:
                return self.to_bytes(1 + ((self.bit_length() + 7) // 8), byteorder='little', signed=True)
            except Exception as e:
                print("coludnt convert negative number %s " % e)
                return False
        try:
            return self.to_bytes((self.bit_length() + 7) // 8, byteorder='little', signed=signed)
        except OverflowError:
            return self.to_bytes(1 + ((self.bit_length() + 7) // 8), byteorder='little', signed=signed)
        except Exception:
            print("COULD NOT CONVERT %s to byte array" % self)

    def __abs__(self, *args, **kwargs):  # real signature unknown
        return BigInteger(super(BigInteger, self).__abs__(*args, **kwargs))

    def __add__(self, *args, **kwargs):  # real signature unknown
        return BigInteger(super(BigInteger, self).__add__(*args, **kwargs))

    def __mod__(self, *args, **kwargs):  # real signature unknown
        return BigInteger(super(BigInteger, self).__mod__(*args, **kwargs))

    def __mul__(self, *args, **kwargs):  # real signature unknown
        return BigInteger(super(BigInteger, self).__mul__(*args, **kwargs))

    def __neg__(self, *args, **kwargs):  # real signature unknown
        return BigInteger(super(BigInteger, self).__neg__(*args, **kwargs))

    def __str__(self, *args, **kwargs):  # real signature unknown
        return super(BigInteger, self).__str__(*args, **kwargs)

    def __sub__(self, *args, **kwargs):  # real signature unknown
        return BigInteger(super(BigInteger, self).__sub__(*args, **kwargs))

    def __truediv__(self, *args, **kwargs):  # real signature unknown
        return BigInteger(int(super(BigInteger, self).__truediv__(*args, **kwargs)))


ZERO = BigInteger(0)
ONE = BigInteger(1)

# XXX END boa/blockchain/vm/BigInteger.py

# XXX BEGIN boa/code/vmtoken.py
print("loading boa/code/vmtoken.py")

#from boa.code import pyop

#from boa.code.byteplay3 import Label

#from boa.blockchain.vm import VMOp
#from boa.blockchain.vm.BigInteger import BigInteger

#from collections import OrderedDict

NEO_SC_FRAMEWORK = 'boa.blockchain.vm.'

#import pdb


class VMToken():
    """

    """
    addr = None

    pytoken = None

    data = None

    vm_op = None

    src_method = None

    target_method = None

    is_annotation = None

    updatable_data = None

    @property
    def out_op(self):
        """

        :return:
        """
        if type(self.vm_op) is int:
            return self.vm_op
        elif type(self.vm_op) is bytes:
            return ord(self.vm_op)
        else:
            raise Exception('Invalid op: %s ' % self.vm_op)

    def __init__(self, vm_op=None, pytoken=None, addr=None, data=None):
        self.vm_op = vm_op
        self.pytoken = pytoken
        self.addr = addr

        if self.pytoken is not None and hasattr(self.pytoken, 'data'):
            self.data = self.pytoken.data

        self.data = data

        self.src_method = None
        self.target_method = None

        self.is_annotation = False


class VMTokenizer():
    """

    """
    method = None

    _address = None

    vm_tokens = None

    total_param_and_body_count_token = None

    def __init__(self, method):
        self.method = method
        self._address = 0
        self.vm_tokens = OrderedDict()

        self.method_begin_items()

    def to_s(self):
        """

        """
        lineno = self.method.start_line_no
        pstart = True
        for i, (key, value) in enumerate(self.vm_tokens.items()):

            if value.pytoken:
                pt = value.pytoken

                do_print_line_no = False
                to_label = None
                from_label = '    '
                if pt.line_no != lineno:
                    print("\n")
                    lineno = pt.line_no
                    do_print_line_no = True

                if pt.args and type(pt.args) is Label:
                    addr = value.addr
                    if value.data is not None:
                        plus_addr = int.from_bytes(
                            value.data, 'little', signed=True)
                        target_addr = addr + plus_addr
                        to_label = 'to %s    [ %s ]' % (target_addr, pt.args)
                    else:
                        to_label = 'from << %s ' % pt.args
                        #                    to_label = 'to %s ' % pt.args
                elif pt.jump_label:
                    from_label = ' >> '
                    to_label = 'from [%s]' % pt.jump_label

                ds = ''
                if value.data is not None:
                    try:
                        ds = int.from_bytes(value.data, 'little', signed=True)
                    except Exception as e:
                        pass
                    if type(ds) is not int and len(ds) < 1:
                        try:
                            ds = value.data.decode('utf-8')
                        except Exception as e:
                            pass

                if pt.py_op == pyop.CALL_FUNCTION:
                    to_label = '%s %s ' % (pt.func_name, pt.func_params)

                lno = "{:<10}".format(
                    pt.line_no if do_print_line_no or pstart else '')
                addr = "{:<4}".format(key)
                op = "{:<20}".format(str(pt.py_op))
                arg = "{:<50}".format(
                    to_label if to_label is not None else pt.arg_s)
                data = "[data] {:<20}".format(ds)
                print("%s%s%s%s%s%s" % (lno, from_label, addr, op, arg, data))

            pstart = False

    def to_b(self):
        """

        :return:
        """
        b_array = bytearray()
        for key, vm_token in self.vm_tokens.items():

            b_array.append(vm_token.out_op)

            if vm_token.data is not None and vm_token.vm_op != VMOp.NOP:
                b_array = b_array + vm_token.data

        return b_array

    def method_begin_items(self):

        # we just need to inssert the total number of arguments + body variables
        # which is the length of the method `local_stores` dictionary
        # then create a new array for the vm to store
        """

        """
        total_items = self.method.total_lines \
            + len(self.method.args) \
            + self.method.dynamic_iterator_count

        self.total_param_and_body_count_token = self.insert_push_integer(
            total_items)
        self.total_param_and_body_count_token.updatable_data = total_items
        self.insert1(VMOp.NEWARRAY)
        self.insert1(VMOp.TOALTSTACK)

        for index, arg in enumerate(self.method.args):
            self.convert_load_parameter(arg, index)

    def update_method_begin_items(self):
        """

        """
        num_current_items = self.total_param_and_body_count_token.updatable_data

        if self.method.dynamic_iterator_count > 0:
            num_current_items += self.method.dynamic_iterator_count
            self.update_push_integer(
                self.total_param_and_body_count_token, num_current_items)

    def insert_vm_token_at(self, vm_token, index):
        """

        :param vm_token:
        :param index:
        """
        self.vm_tokens[index] = vm_token

    def update1(self, vmtoken, vm_op, data=None):
        """

        :param vmtoken:
        :param vm_op:
        :param data:
        :return:
        """
        vmtoken.vm_op = vm_op
        vmtoken.data = data

        self.insert_vm_token_at(vmtoken, vmtoken.addr)

        return vmtoken

    def update_push_data(self, vmtoken, data):
        """

        :param vmtoken:
        :param data:
        :return:
        """
        dlen = len(data)

        if dlen == 0:
            return self.update1(vmtoken, VMOp.PUSH0)

        elif dlen <= 75:
            return self.update1(vmtoken, dlen, data)

        if dlen < 0x100:
            prefixlen = 1
            code = VMOp.PUSHDATA1

        elif dlen < 0x1000:
            prefixlen = 2
            code = VMOp.PUSHDATA2

        else:
            prefixlen = 4
            code = VMOp.PUSHDATA4

        byts = bytearray(dlen.to_bytes(prefixlen, 'little')) + data

        return self.update1(vmtoken, code, byts)

    def update_push_integer(self, vmtoken, i):
        """

        :param vmtoken:
        :param i:
        :return:
        """
        if i == 0:
            return self.update1(vmtoken, VMOp.PUSH0)
        elif i == -1:
            return self.insert1(vmtoken, VMOp.PUSHM1)
        elif i > 0 and i <= 16:
            out = 0x50 + i
            return self.update1(vmtoken, out)

        bigint = BigInteger(i)
        outdata = bigint.ToByteArray()

        return self.update_push_data(vmtoken, outdata)

    def insert1(self, vm_op, data=None):
        """

        :param vm_op:
        :param data:
        :return:
        """
        start_addr = self._address

        vmtoken = VMToken(vm_op=vm_op, addr=start_addr, data=data)

        self._address += 1

        if vmtoken.data is not None:
            self._address += len(vmtoken.data)

        self.insert_vm_token_at(vmtoken, vmtoken.addr)

        return vmtoken

    def insert_push_data(self, data):
        """

        :param data:
        :return:
        """
        dlen = len(data)

        if dlen == 0:
            return self.insert1(VMOp.PUSH0)

        elif dlen <= 75:
            return self.insert1(dlen, data)

        if dlen < 0x100:
            prefixlen = 1
            code = VMOp.PUSHDATA1

        elif dlen < 0x1000:
            prefixlen = 2
            code = VMOp.PUSHDATA2

        else:
            prefixlen = 4
            code = VMOp.PUSHDATA4

        byts = bytearray(dlen.to_bytes(prefixlen, 'little')) + data

        return self.insert1(code, byts)

    def insert_push_integer(self, i):
        """

        :param i:
        :return:
        """
        if i == 0:
            return self.insert1(VMOp.PUSH0)
        elif i == -1:
            return self.insert1(VMOp.PUSHM1)
        elif i > 0 and i <= 16:
            out = 0x50 + i
            return self.insert1(out)

        bigint = BigInteger(i)
        outdata = bigint.ToByteArray()

        return self.insert_push_data(outdata)

    def convert1(self, vm_op, py_token=None, data=None):
        """

        :param vm_op:
        :param py_token:
        :param data:
        :return:
        """
        start_addr = self._address

        vmtoken = VMToken(vm_op=vm_op, addr=start_addr,
                          pytoken=py_token, data=data)

        self._address += 1

        if vmtoken.data is not None and type(vmtoken.data) is not Label:
            self._address += len(data)

        self.insert_vm_token_at(vmtoken, start_addr)

        return vmtoken

    def convert_new_array(self, vm_op, py_token=None, data=None):

        # push the length of the array
        """

        :param vm_op:
        :param py_token:
        :param data:
        """
        if type(py_token.args) is int:

            self.insert_push_integer(py_token.args)
        else:
            self.convert_load_local(py_token, py_token.args)

        self.convert1(VMOp.PACK, py_token)

    def convert_push_data(self, data, py_token=None):
        """

        :param data:
        :param py_token:
        :return:
        """
        dlen = len(data)
        if dlen == 0:
            return self.convert1(VMOp.PUSH0, py_token=py_token)
        elif dlen <= 75:
            return self.convert1(len(data), py_token=py_token, data=data)

        if dlen < 0x100:
            prefixlen = 1
            code = VMOp.PUSHDATA1
        elif dlen < 0x1000:
            prefixlen = 2
            code = VMOp.PUSHDATA2
        else:
            prefixlen = 4
            code = VMOp.PUSHDATA4

        byts = bytearray(dlen.to_bytes(prefixlen, 'little')) + data

        return self.convert1(code, py_token=py_token, data=byts)

    def convert_push_integer(self, i, py_token=None):
        """

        :param i:
        :param py_token:
        :return:
        """
        if i == 0:
            return self.convert1(VMOp.PUSH0, py_token=py_token)
        elif i == -1:
            return self.convert1(VMOp.PUSHM1, py_token=py_token)
        elif i > 0 and i <= 16:
            out = 0x50 + i
            return self.convert1(out, py_token=py_token)

        bigint = BigInteger(i)

        outdata = bigint.ToByteArray()

        return self.convert_push_data(outdata, py_token=py_token)

    def convert_store_local(self, py_token):

        # set array
        """

        :param py_token:
        """
        self.convert1(VMOp.FROMALTSTACK, py_token=py_token)
        self.convert1(VMOp.DUP)
        self.convert1(VMOp.TOALTSTACK)

        local_name = py_token.args

        position = self.method.local_stores[local_name]

        # set i the index of the local variable to be stored
        self.convert_push_integer(position)

        # set item
        self.convert_push_integer(2)
        self.convert1(VMOp.ROLL)
        self.convert1(VMOp.SETITEM)

    def convert_load_local(self, py_token, name=None):
        """

        :param py_token:
        :param name:
        """
        if name is not None:
            local_name = name
        else:
            local_name = py_token.args

        # check to see if this local is a variable
        if local_name in self.method.local_stores:

            position = self.method.local_stores[local_name]

            # get array
            self.convert1(VMOp.FROMALTSTACK, py_token=py_token)
            self.convert1(VMOp.DUP)
            self.convert1(VMOp.TOALTSTACK)

            # get i
            self.convert_push_integer(position)
            self.convert1(VMOp.PICKITEM)

        else:
            py_token.func_params = []
            py_token.func_name = local_name

            self.convert_method_call(py_token)

    def insert_unknown_type(self, item):
        """

        :param item:
        """
        if type(item) is int:
            self.insert_push_integer(item)

        elif type(item) is str:
            str_bytes = item.encode('utf-8')
            self.insert_push_data(str_bytes)

        elif type(item) is bytearray:
            self.insert_push_data(bytes(item))

        elif type(item) is bytes:
            self.insert_push_data(item)

        elif type(item) is bool:
            self.insert_push_data(item)
        elif type(item) == type(None):
            self.insert_push_data(bytearray(0))
        else:
            raise Exception("Could not load type %s for item %s " %
                            (type(item), item))

    def convert_set_element(self, arg, position):

        #        print("converting set element %s %s" % (position, type(position)))
        """

        :param arg:
        :param position:
        """
        if type(position) is int:

            self.insert_push_integer(position)
        elif type(position) is str:
            self.convert_load_local(None, name=position)

        if type(arg.array_item) is str:

            # first we'll look for the local variable with name of the str
            if arg.array_item in self.method.local_stores:
                self.convert_load_local(None, name=arg.array_item)
            # otherwise we'll do the unknown type thing
            else:
                self.insert_unknown_type(arg.array_item)
        else:
            self.insert_unknown_type(arg.array_item)

        self.convert1(VMOp.SETITEM, arg)

    def convert_load_parameter(self, arg, position):
        """

        :param arg:
        :param position:
        """
        length = len(self.method.local_stores)
        self.method.local_stores[arg] = length

        # get array
        self.insert1(VMOp.FROMALTSTACK)
        self.insert1(VMOp.DUP)
        self.insert1(VMOp.TOALTSTACK)

        self.insert_push_integer(position)
        self.insert_push_integer(2)

        self.insert1(VMOp.ROLL)
        self.insert1(VMOp.SETITEM)

    def convert_built_in_list(self, pytoken):
        """

        :param pytoken:
        """
        new_array_len = 0
        lenfound = False
        for index, token in enumerate(pytoken.func_params):

            if token.args == 'length' and not lenfound:
                # first we see if a constant ( ie integer was passed in

                new_array_len = pytoken.func_params[index + 1].args

                if type(new_array_len) is int:
                    self.insert_push_integer(new_array_len)
                else:
                    self.convert_load_local(None, name=new_array_len)
                lenfound = True

        if not lenfound:
            self.insert_push_integer(0)
        self.convert1(VMOp.NEWARRAY, pytoken)

    def convert_build_slice(self, pytoken):

        # this was fun!

        # rotate so list is on the top, then move it to alt stack
        self.convert1(VMOp.ROT)
        self.convert1(VMOp.TOALTSTACK, py_token=pytoken)

        # swap the end index and the start index, duplicate start index to alt stack
        self.convert1(VMOp.SWAP)
        self.convert1(VMOp.DUP)
        self.convert1(VMOp.TOALTSTACK)

        # subtract end index from start index, this is placed on the stack
        self.convert1(VMOp.SUB)

        # get the start index and list from alt stack
        self.convert1(VMOp.FROMALTSTACK)
        self.convert1(VMOp.FROMALTSTACK)

        # swap the list and the start index
        self.convert_push_integer(2)
        self.convert1(VMOp.XSWAP)

        # and now perform substr. whew.
        self.convert1(VMOp.SUBSTR)

    def convert_method_call(self, pytoken):

        # special case for list initialization
        """

        :param pytoken:
        :return:
        """
        if pytoken.func_name == 'list':
            return self.convert_built_in_list(pytoken)
        elif pytoken.func_name == 'bytearray':
            return self.convert_push_data(bytes(pytoken.func_params[0].args), pytoken)
        elif pytoken.func_name == 'bytes':
            return self.convert_push_data(pytoken.func_params[0].args, pytoken)
        elif pytoken.func_name == 'AppCall':
            scripthash_token = pytoken.func_params.pop(0)
            pytoken.script_hash_token = scripthash_token.args

        for t in pytoken.func_params:
            t.to_vm(self)

        param_len = len(pytoken.func_params)

        if param_len <= 1:
            pass
        elif param_len == 2:
            # if we are using concat or take, we don't want to swap
            if pytoken.func_name != 'concat' and pytoken.func_name != 'take':
                self.insert1(VMOp.SWAP)

        elif param_len == 3:

            if pytoken.func_name != 'substr':
                self.insert_push_integer(2)
                self.insert1(VMOp.XSWAP)

        else:
            half_p = int(param_len / 2)

            for i in range(0, half_p):
                save_to = param_len - 1 - i

                self.insert_push_integer(save_to)
                self.insert1(VMOp.PICK)

                self.insert_push_integer(i + 1)
                self.insert1(VMOp.PICK)

                self.insert_push_integer(save_to + 2)
                self.insert1(VMOp.XSWAP)
                self.insert1(VMOp.DROP)

                self.insert_push_integer(i + 1)
                self.insert1(VMOp.XSWAP)
                self.insert1(VMOp.DROP)

        self.insert1(VMOp.NOP)

        fname = pytoken.func_name
        full_name = None
        for m in self.method.module.methods:
            if fname == m.name:
                full_name = m.full_name

        # operational call like len(items) or abs(value)
        if self.is_op_call(fname):
            vmtoken = self.convert_op_call(fname, pytoken)

        # runtime.notify event
        elif self.is_notify_event(pytoken):
            vmtoken = self.convert_notify_event(pytoken)

        # app call ( for calling other contracts on blockchain )
        elif self.is_smart_contract_call(pytoken):
            vmtoken = self.convert_smart_contract_call(pytoken)

        elif self.is_sys_call(full_name):
            vmtoken = self.convert_sys_call(full_name, pytoken)

        # used for python specific built in methods like `enumerate` or `tuple`
        elif self.is_built_in(fname):
            vmtoken = self.convert_built_in(fname, pytoken)

        # otherwise we assume the method is defined by the module
        else:
            vmtoken = self.convert1(
                VMOp.CALL, py_token=pytoken, data=bytearray(b'\x05\x00'))

            vmtoken.src_method = self.method
            vmtoken.target_method = pytoken.func_name

        return vmtoken

    def is_op_call(self, op):
        """

        :param op:
        :return:
        """
        if op in ['len', 'abs', 'min', 'max', 'concat', 'take', 'substr',
                  'sha1', 'sha256', 'hash160', 'hash256',
                  'verify_signature', 'verify_signatures']:
            return True
        return False

    def convert_op_call(self, op, pytoken=None):
        """

        :param op:
        :param pytoken:
        :return:
        """
        if op == 'len':
            return self.convert1(VMOp.ARRAYSIZE, pytoken)
        elif op == 'abs':
            return self.convert1(VMOp.ABS, pytoken)
        elif op == 'min':
            return self.convert1(VMOp.MIN, pytoken)
        elif op == 'max':
            return self.convert1(VMOp.MAX, pytoken)
        elif op == 'concat':
            return self.convert1(VMOp.CAT, pytoken)
        elif op == 'take':
            return self.convert1(VMOp.LEFT, pytoken)
        elif op == 'substr':
            return self.convert1(VMOp.SUBSTR, pytoken)
        elif op == 'sha1':
            return self.convert1(VMOp.SHA1, pytoken)
        elif op == 'sha256':
            return self.convert1(VMOp.SHA256, pytoken)
        elif op == 'hash160':
            return self.convert1(VMOp.HASH160, pytoken)
        elif op == 'hash256':
            return self.convert1(VMOp.HASH256, pytoken)
        elif op == 'verify_signature':
            return self.convert1(VMOp.CHECKSIG, pytoken)
        elif op == 'verify_signatures':
            return self.convert1(VMOp.CHECKMULTISIG, pytoken)
        return None

    def is_sys_call(self, op):
        """

        :param op:
        :return:
        """
        if op is not None and NEO_SC_FRAMEWORK in op:
            if 'TriggerType' not in op:  # we will compile TriggerType normally
                return True
        return False

    def convert_sys_call(self, op, pytoken=None):
        """

        :param op:
        :param pytoken:
        :return:
        """
        syscall_name = op.replace(NEO_SC_FRAMEWORK, '').encode('utf-8')
        length = len(syscall_name)
        ba = bytearray([length]) + bytearray(syscall_name)
        pytoken.is_sys_call = False
        vmtoken = self.convert1(VMOp.SYSCALL, pytoken, data=ba)
        self.insert1(VMOp.NOP)
        return vmtoken

    def is_built_in(self, op):
        """

        :param op:
        :return:
        """
        if op in ['zip', 'type', 'tuple', 'super', 'str', 'slice',
                  'set', 'reversed', 'property', 'memoryview',
                  'map', 'list', 'frozenset', 'float', 'filter',
                  'enumerate', 'dict', 'divmod', 'complex', 'bytes', 'bytearray', 'bool',
                  'int', 'vars', 'sum', 'sorted', 'round', 'setattr', 'getattr',
                  'rep', 'quit', 'print', 'pow', 'ord', 'oct', 'next', 'locals', 'license',
                  'iter', 'isinstance', 'issubclass', 'input', 'id', 'hex',
                  'help', 'hash', 'hasattr', 'globals', 'format', 'exit',
                  'exec', 'eval', 'dir', 'deleteattr', 'credits', 'copyright',
                  'compile', 'chr', 'callable', 'bin', 'ascii', 'any', 'all', ]:
            return True

        return False

    def convert_built_in(self, op, pytoken):
        """

        :param op:
        :param pytoken:
        :return:
        """
        if op == 'print':
            syscall_name = 'Neo.Runtime.Log'.encode('utf-8')
            length = len(syscall_name)
            ba = bytearray([length]) + bytearray(syscall_name)
            vmtoken = self.convert1(VMOp.SYSCALL, pytoken, data=ba)
            self.insert1(VMOp.NOP)
            return vmtoken

        raise NotImplementedError(
            "[Compilation error] Built in %s is not implemented" % op)

    def is_notify_event(self, pytoken):
        """

        :param pytoken:
        :return:
        """
        name = pytoken.func_name

        for action in self.method.module.actions:
            if action.method_name == name:
                return True
        return False

    def convert_notify_event(self, pytoken):
        """

        :param pytoken:
        :return:
        """
        event_action = None
        for action in self.method.module.actions:
            if action.method_name == pytoken.func_name:
                event_action = action
        if event_action is None:
            raise Exception("Event action not found")

        # push the event name
        event_name = event_action.event_name.encode('utf-8')
        self.convert_push_data(event_name, py_token=pytoken)

        # push the num params
        self.convert_push_integer(len(event_action.event_args))

        # pack the array
        self.convert1(VMOp.PACK)

        # insert syscall
        syscall_name = 'Neo.Runtime.Notify'.encode('utf-8')
        length = len(syscall_name)
        ba = bytearray([length]) + bytearray(syscall_name)
        vmtoken = self.convert1(VMOp.SYSCALL, pytoken, data=ba)

        return vmtoken

    def is_smart_contract_call(self, pytoken):
        """

        :param pytoken:
        :return:
        """
        name = pytoken.func_name

        if name == 'AppCall':
            return True

        for appcall in self.method.module.app_call_registrations:
            if appcall.method_name == name:
                return True
        return False

    def convert_smart_contract_call(self, pytoken):
        """

        :param pytoken:
        :return:
        """

        # the following converts app calls of the pattern
        # m = AppCall(script_hash, *args)
        if pytoken.script_hash_addr is not None:

            from boa.code.items import SmartContractAppCall

            shash = SmartContractAppCall.ToScriptHashData(pytoken.script_hash_addr)

            vmtoken = self.convert1(VMOp.APPCALL, py_token=pytoken, data=shash)
            return vmtoken

        # this is used for app calls that are registered
        # using RegisterAppCall(script_hash, *args)
        sc_appcall = None
        for appcall in self.method.module.app_call_registrations:
            if appcall.method_name == pytoken.func_name:
                sc_appcall = appcall
        if sc_appcall is None:
            raise Exception("Smart Contract Appcall %s not found " %
                            pytoken.func_name)

        # push the contract hash
        vmtoken = self.convert1(
            VMOp.APPCALL, py_token=pytoken, data=sc_appcall.script_hash_addr)

        return vmtoken

# XXX END boa/code/vmtoken.py

# XXX BEGIN boa/code/block.py
print("loading boa/code/block.py")

#from boa.code.byteplay3 import Opcode, Label
#from boa.code.pytoken import PyToken
#from boa.code import pyop
#import pdb


class Block():

    """

    """
    forloop_counter = 0

    localmethod_counter = 0

    oplist = None  # list

    _label = None  # list

    iterable_variable = None
    iterable_loopcounter = None
    iterable_looplength = None
    iterable_item_name = None

    list_comp_iterable_variable = None
    list_comp_iterable_loopcounter = None
    list_comp_iterable_looplength = None
    list_comp_iterable_item_name = None

    slice_item_length = None

    has_dynamic_iterator = False

    local_func_name = None
    local_func_varname = None

    def __init__(self, operation_list):
        self.oplist = operation_list

        self.iterable_variable = None
        self.iterable_loopcounter = None
        self.iterable_looplength = None
        self.iterable_item_name = None

        self.list_comp_iterable_variable = None
        self.list_comp_iterable_loopcounter = None
        self.list_comp_iterable_looplength = None
        self.list_comp_iterable_item_name = None

        self.has_dynamic_iterator = False

        self.slice_item_length = None

    def __str__(self):
        if self._label:
            return '[Block] %s          [label] %s' % (self.oplist, self._label)
        return '[Block]: %s' % self.oplist

    def set_label(self, label):
        """

        :param label:
        """
        self._label = label
        self.oplist[0].jump_label = label

    @property
    def line(self):
        """

        :return:
        """
        if len(self.oplist):
            token = self.oplist[0]
            return token.line_no
        return None

    @property
    def has_load_attr(self):
        """

        :return:
        """
        for token in self.oplist:
            if token.py_op == pyop.LOAD_ATTR:
                return True
        return False

    @property
    def has_make_function(self):
        """

        :return:
        """
        for token in self.oplist:
            if token.py_op == pyop.MAKE_FUNCTION:
                return True
        return False

    @property
    def has_slice(self):
        """

        :return:
        """
        for token in self.oplist:
            if token.py_op == pyop.BUILD_SLICE:
                return True

    @property
    def is_return(self):
        """

        :return:
        """
        if len(self.oplist):
            token = self.oplist[-1]
            if token.py_op == pyop.RETURN_VALUE:
                return True
        return False

    @property
    def is_iter(self):
        """

        :return:
        """
        has_get_iter = False
        for token in self.oplist:
            if token.py_op == pyop.GET_ITER:
                has_get_iter = True
            elif token.py_op == pyop.MAKE_FUNCTION:
                return False
        return has_get_iter

    @property
    def iterable_local_vars(self):
        """

        :return:
        """
        return [
            self.iterable_looplength,
            self.iterable_loopcounter,
            self.iterable_item_name,
        ]

    @property
    def list_comp_iterable_local_vars(self):
        """

        :return:
        """
        return [
            self.list_comp_iterable_looplength,
            self.list_comp_iterable_loopcounter,
            self.list_comp_iterable_item_name,
            self.list_comp_iterable_variable,
        ]

    @property
    def has_unprocessed_method_calls(self):
        """

        :return:
        """
#        if self.has_slice:
#            return False
#        if self.is_list_comprehension:
#            return False
        for token in self.oplist:
            if token.py_op == pyop.CALL_FUNCTION and not token.func_processed:
                return True
        return False

    @property
    def has_unprocessed_array_sub(self):
        """

        :return:
        """
        for token in self.oplist:
            if token.py_op == pyop.STORE_SUBSCR and not token.array_processed:
                return True
        return False

    @property
    def has_unprocessed_array(self):
        """

        :return:
        """
        for token in self.oplist:
            if token.py_op == pyop.BUILD_LIST and not token.array_processed:
                return True
        return False

    @property
    def is_list_comprehension(self):
        """

        :return:
        """
        if self.has_make_function:
            for token in self.oplist:
                if token.py_op == pyop.GET_ITER:
                    return True
        if self.list_comp_iterable_variable:
            return True
        return False

    def preprocess_load_attr(self, method):
        """

        :param method:
        """
        while self.has_load_attr:

            index_to_rep = -1
            new_call = None

            for index, token in enumerate(self.oplist):

                if token.py_op == pyop.LOAD_ATTR:

                    what_to_load = 'Get%s' % token.args

                    call_func = PyToken(
                        Opcode(pyop.CALL_FUNCTION), lineno=self.line, index=-1, args=what_to_load)
                    call_func.func_processed = True
                    call_func.func_name = what_to_load
                    call_func.func_params = [self.oplist[index - 1]]

                    index_to_rep = index
                    new_call = call_func

            if index_to_rep > -1 and new_call is not None:
                self.oplist[index_to_rep] = new_call
                del self.oplist[index_to_rep - 1]

    def preprocess_make_function(self, method):
        """

        :param method:
        """
        code_obj = self.oplist[0].args
        code_obj_name = self.oplist[1].args
        self.local_func_name = "%s_%s" % (
            code_obj_name, Block.localmethod_counter)
        Block.localmethod_counter += 1

        #from boa.code.method import Method  #XXX avoid circular deps

        m = Method(code_object=code_obj, parent=method.parent,
                   make_func_name=self.local_func_name)
        method.parent.add_method(m)

        self.local_func_varname = self.oplist[-1].args

    def preprocess_slice(self):
        """
        this method processes slices of strings or byte arrays such as item[1:3]
        """
        index_to_remove = -1

        for index, token in enumerate(self.oplist):
            if token.py_op == pyop.BUILD_SLICE:
                # first, we want to take out the BINARY_SUBSC op, since we wont need it
                index_to_remove = index + 1

                # now we want to check the second item, for example item[2:4], we need to check 4
                # if you do item[2:], in python, normally the end is inferred
                # but we get None.
                # in that case, we need to convert None into the length of the item being sliced
                end_op = self.oplist[index - 1]

                if end_op.args is None:
                    # 0xffffff
                    # if you have a list greater than that length, well you'll have other problems than this
                    max_len = 16777215
                    end_op.args = max_len

        if index_to_remove > -1:
            del self.oplist[index_to_remove]

    def preprocess_iter(self):

        # in a better world this would be done in a more efficient way
        # for now this is kept to be as understandable as possible
        """

        """
        loopsetup = self.oplist[0]
        loopsetup.args = None
        loopsetup.jump_label = None

        # first we need to create a loop counter variable
        self.iterable_loopcounter = 'forloop_counter_%s' % Block.forloop_counter

        # load the value 0
        loopcounter_start_ld_const = PyToken(
            op=Opcode(pyop.LOAD_CONST), lineno=loopsetup.line_no, index=-1, args=0)
        # now store the loop counter
        loopcounter_store_fast = PyToken(op=Opcode(
            pyop.STORE_FAST), lineno=loopsetup.line_no, index=-1, args=self.iterable_loopcounter)

        # this loads the list that is going to be iterated over ( LOAD_FAST )
        # this will be removed... its added into the call get length token function params
        # unless this is a dynamic iteration, like for x in range(x,y)
        dynamic_iterable_items = []

        iterable_load = self.oplist[1]

        self.iterable_item_name = iterable_load.args

        if iterable_load.py_op == pyop.CALL_FUNCTION:

            self.has_dynamic_iterator = True

            self.iterable_item_name = 'forloop_dynamic_range_%s' % Block.forloop_counter

            dynamic_iterator_store_fast = PyToken(op=Opcode(pyop.STORE_FAST), lineno=loopsetup.line_no, index=-1,
                                                  args=self.iterable_item_name)

            # if we're calling a method in this for i in, like for i in range(x,y) then we need
            # to call the function
            dynamic_iterable_items = [
                iterable_load, dynamic_iterator_store_fast]

        # Now we need to get the length of that list, and store that as a local variable

        call_get_length_token = PyToken(
            op=Opcode(pyop.CALL_FUNCTION), lineno=loopsetup.line_no, args=1)
        call_get_length_token.func_params = [iterable_load]
        call_get_length_token.func_name = 'len'

        # now we need a variable name to store the length of the array
        self.iterable_looplength = 'forloop_length_%s' % Block.forloop_counter

        # now store the variable which is the output of the len(items) call
        looplength_store_op = PyToken(op=Opcode(
            pyop.STORE_FAST), lineno=loopsetup.line_no, index=-1, args=self.iterable_looplength)

        get_iter = self.oplist[2]
        for_iter = self.oplist[3]

        store_iterable_name = self.oplist[4]

        # set the iterable variable name ( for example, i ) so that the loop body can use it
        self.iterable_variable = store_iterable_name.args

        ld_loopcounter = PyToken(op=Opcode(
            pyop.LOAD_FAST), lineno=loopsetup.line_no, index=-1, args=self.iterable_loopcounter)

        ld_loop_length = PyToken(op=Opcode(
            pyop.LOAD_FAST), lineno=loopsetup.line_no, index=-1, args=self.iterable_looplength)

        new__compare_op = PyToken(
            op=Opcode(pyop.COMPARE_OP), lineno=loopsetup.line_no, index=-1, args='<')
        new__popjump_op = PyToken(op=Opcode(
            pyop.POP_JUMP_IF_FALSE), lineno=loopsetup.line_no, index=-1, args=for_iter.args)

        for_iter.args = None

        self.oplist = [
            loopsetup,  # SETUP_LOOP

            get_iter,  # GET_ITER, keep this in for now


            # the following 4 ops set up the iterator

            loopcounter_start_ld_const,  # LOAD_CONST 0
            loopcounter_store_fast,  # STORE_FAST forloopcounter_X

            # dynamic load loop stuff would go here

            call_get_length_token,  # CALL_FUNCTION 1

            looplength_store_op,  # STORE_FAST forloop_length_X


            # these last 5 ops controls the operation of the loop

            for_iter,  # tihs is the jump target for the end of the loop execution block

            ld_loopcounter,  # load in the loop counter LOAD_FAST forloopcounter_X

            ld_loop_length,  # load in the loop length LOAD_FAST forloop_length_X

            new__compare_op,  # COMPARE_OP <, this will compare foorloop_counter_X < forloop_length_X

            new__popjump_op  # POP_JUMP_IF_FALSE jumps to the loop exit when counter == length
        ]

        if len(dynamic_iterable_items):
            self.oplist.insert(4, dynamic_iterable_items[0])
            self.oplist.insert(5, dynamic_iterable_items[1])

        Block.forloop_counter += 1

    def process_iter_body(self, setup_block):
        """

        :param setup_block:
        """
        first_op = self.oplist[0]

        #
        # the following loads the iterated item into the block
        #

        # load the iterable collection
        ld_load_iterable = PyToken(op=Opcode(
            pyop.LOAD_FAST), lineno=first_op.line_no, index=-1, args=setup_block.iterable_item_name)

        # load the counter var
        ld_counter = PyToken(op=Opcode(pyop.LOAD_FAST), lineno=first_op.line_no,
                             index=-1, args=setup_block.iterable_loopcounter)

        # binary subscript of the iterable collection
        ld_subscript = PyToken(op=Opcode(pyop.BINARY_SUBSCR),
                               lineno=first_op.line_no, index=-1)

        # now store the iterated item
        st_iterable = PyToken(op=Opcode(
            pyop.STORE_FAST), lineno=first_op.line_no, index=-1, args=setup_block.iterable_variable)

        #
        # the following load the forloop counter and increments it
        #

        # load the counter var
        ld_counter_2 = PyToken(op=Opcode(
            pyop.LOAD_FAST), lineno=first_op.line_no, index=-1, args=setup_block.iterable_loopcounter)
        # load the constant 1
        increment_const = PyToken(
            op=Opcode(pyop.LOAD_CONST), lineno=first_op.line_no, index=-1, args=1)
        # add it to the counter
        increment_add = PyToken(
            op=Opcode(pyop.INPLACE_ADD), lineno=first_op.line_no, index=-1)
        # and store it again
        increment_store = PyToken(op=Opcode(
            pyop.STORE_FAST), lineno=first_op.line_no, index=-1, args=setup_block.iterable_loopcounter)

        self.oplist = [
            ld_load_iterable, ld_counter, ld_subscript, st_iterable,

            ld_counter_2, increment_const, increment_add, increment_store

        ] + self.oplist

    def preprocess_method_calls(self, orig_method):
        """

        :param orig_method:
        """
        while self.has_unprocessed_method_calls:
            start_index_change = None
            end_index_change = None
            changed_items = None

            for index, token in enumerate(self.oplist):
                #                print("TOKEN::: %s %s " % (token.jump_label, token.args))

                if token.py_op == pyop.CALL_FUNCTION and not token.func_processed:

                    token.func_processed = True
                    param_count = token.args

                    # why would param count be 256 when calling w/ kwargs?
                    # when keyword args are sent, the param count is 256 * num paramms?
                    if param_count % 256 == 0:
                        param_count = 2 * int(param_count / 256)

                    params = self.oplist[index - param_count:index]

                    call_method_op = self.oplist[index - param_count - 1]

                    call_method_type = call_method_op.py_op
                    call_method_name = call_method_op.args

                    # we need to check if this is a method
                    # that is local to this block's method
                    for key, value in orig_method.local_methods.items():
                        if key == call_method_name:
                            call_method_name = value

                    token.func_name = call_method_name
                    token.func_type = call_method_type

                    # if this method is the target of a jump
                    # or if one of its parameters is the target of a jump
                    # we need to catch that and use that jump label
                    # otherwise bad things
                    if call_method_op.jump_label is not None:
                        if len(params) > 0:
                            params[0].jump_label = call_method_op.jump_label
                        else:
                            token.jump_label = call_method_op.jump_label

                    token.func_params = params

                    changed_items = [token]

                    start_index_change = index - param_count - 1
                    end_index_change = index

            if start_index_change is not None and end_index_change is not None:
                tstart = self.oplist[0:start_index_change]
                tend = self.oplist[end_index_change + 1:]
                self.oplist = tstart + changed_items + tend

    def preprocess_array_subs(self):
        """

        """
        while self.has_unprocessed_array_sub:
            start_index_change = None
            end_index_change = None
            changed_items = None

            for index, token in enumerate(self.oplist):
                if token.py_op == pyop.STORE_SUBSCR and not token.array_processed:
                    token.array_processed = True
                    start_index_change = index - 3
                    end_index_change = index

                    item_to_sub = self.oplist[index - 3].args
                    array_to_sub = self.oplist[index - 2].args
                    index_to_sub_at = self.oplist[index - 1].args
                    changed_items = []

                    # load the array to set the item into
                    ld_op = PyToken(Opcode(pyop.LOAD_FAST),
                                    token.line_no, args=array_to_sub)
                    changed_items.append(ld_op)

                    # create the setitem op
                    settoken = PyToken(Opcode(
                        pyop.SETITEM), token.line_no, args=index_to_sub_at, array_item=item_to_sub)
                    changed_items.append(settoken)

            if start_index_change is not None and end_index_change is not None:
                tstart = self.oplist[0:start_index_change]
                tend = self.oplist[end_index_change + 2:]
                self.oplist = tstart + changed_items + tend

    def preprocess_arrays(self):
        """

        """
        while self.has_unprocessed_array:

            blist_start_index = None
            blist_end_index = None
            array_items = []
            for index, token in enumerate(self.oplist):
                if token.py_op == pyop.BUILD_LIST and not token.array_processed and blist_start_index is None:

                    num_list_items = token.args
                    blist_start_index = index - num_list_items
                    blist_end_index = index
                    array_items = self.oplist[index -
                                              num_list_items:num_list_items]
                    array_items.reverse()

                    token.array_processed = True

            if blist_start_index is not None:
                self.oplist = self.oplist[0:blist_start_index] + \
                    array_items + self.oplist[blist_end_index:]

    def mark_as_end(self):
        """

        """
        tstart = self.oplist[:-1]
        tend = self.oplist[-1:]

        newitems = [PyToken(Opcode(pyop.NOP), self.line),
                    #                    PyToken(pyop.DROP_BODY, self.line),
                    PyToken(Opcode(pyop.FROMALTSTACK), self.line),
                    PyToken(Opcode(pyop.DROP), self.line)]

        self.oplist = tstart + newitems + tend

    def preprocess_list_comprehension(self, method):

        # i apologize for the following

        # grab the list comprehestion code object and make a method out of it
        # we will use it later
        """

        :param method:
        """
        code_obj = self.oplist[0].args

        # now get rid of the first 3 ops for now
        self.oplist = self.oplist[3:]

        # setup a loop for the list comp
        setup_loop = PyToken(op=Opcode(pyop.SETUP_LOOP),
                             lineno=self.line, index=-1)

        # first we need to create a loop counter variable
        self.list_comp_iterable_loopcounter = 'list_comp_loop_counter_%s' % Block.forloop_counter

        # load the value 0
        loopcounter_start_ld_const = PyToken(
            op=Opcode(pyop.LOAD_CONST), lineno=self.line, index=-1, args=0)
        # now store the loop counter
        loopcounter_store_fast = PyToken(op=Opcode(pyop.STORE_FAST), lineno=self.line, index=-1,
                                         args=self.list_comp_iterable_loopcounter)

        # this loads the list that is going to be iterated over ( LOAD_FAST )
        # this will be removed... its added into the call get length token function params
        # unless this is a dynamic iteration, like for x in range(x,y)

        iterable_load = self.oplist[0]

        self.list_comp_iterable_item_name = iterable_load.args

        # the following is in the case that we're doing something like for i in range(x,y)
        dynamic_iterable_items = []
        if iterable_load.py_op == pyop.CALL_FUNCTION:
            self.has_dynamic_iterator = True
            self.iterable_item_name = 'forloop_dynamic_range_%s' % Block.forloop_counter
            dynamic_iterator_store_fast = PyToken(op=Opcode(pyop.STORE_FAST), lineno=self.line, index=-1,
                                                  args=self.iterable_item_name)
            # if we're calling a method in this for i in, like for i in range(x,y) then we need
            # to call the function
            dynamic_iterable_items = [
                iterable_load, dynamic_iterator_store_fast]

        # Now we need to get the length of that list, and store that as a local variable
        call_get_length_token = PyToken(
            op=Opcode(pyop.CALL_FUNCTION), lineno=self.line, args=1)
        call_get_length_token.func_processed = True
        call_get_length_token.func_params = [iterable_load]
        call_get_length_token.func_name = 'len'

        # now we need a variable name to store the length of the array
        self.list_comp_iterable_looplength = 'list_comp_loop_length_%s' % Block.forloop_counter

        # now store the variable which is the output of the len(items) call
        looplength_store_op = PyToken(op=Opcode(pyop.STORE_FAST), lineno=self.line, index=-1,
                                      args=self.list_comp_iterable_looplength)

        get_iter = self.oplist[1]

        for_iter_label = Label()
        jmp_if_false_label = Label()

        for_iter = PyToken(op=Opcode(pyop.FOR_ITER),
                           lineno=self.line, index=-1)
        for_iter.jump_label = for_iter_label

        end_block = PyToken(op=Opcode(pyop.POP_BLOCK),
                            lineno=self.line, index=-1)
        end_block.jump_label = jmp_if_false_label

        jmp_abs_back = PyToken(op=Opcode(pyop.JUMP_ABSOLUTE),
                               lineno=self.line, index=-1, args=for_iter_label)

        self.list_comp_iterable_variable = 'list_comp_local_i_%s' % Block.forloop_counter

        ld_loopcounter = PyToken(op=Opcode(pyop.LOAD_FAST), lineno=self.line, index=-1,
                                 args=self.list_comp_iterable_loopcounter)

        ld_loop_length = PyToken(op=Opcode(pyop.LOAD_FAST), lineno=self.line, index=-1,
                                 args=self.list_comp_iterable_looplength)

        new__compare_op = PyToken(
            op=Opcode(pyop.COMPARE_OP), lineno=self.line, index=-1, args='<')
        new__popjump_op = PyToken(op=Opcode(pyop.POP_JUMP_IF_FALSE), lineno=self.line, index=-1,
                                  args=jmp_if_false_label)

        # ok now we do the loop block stuff here

        #
        # the following loads the iterated item into the block
        #

        # load the iterable collection
        ld_load_iterable = PyToken(op=Opcode(pyop.LOAD_FAST), lineno=self.line, index=-1,
                                   args=self.list_comp_iterable_item_name)

        # load the counter var
        ld_counter = PyToken(op=Opcode(pyop.LOAD_FAST), lineno=self.line, index=-1,
                             args=self.list_comp_iterable_loopcounter)

        # binary subscript of the iterable collection
        ld_subscript = PyToken(
            op=Opcode(pyop.BINARY_SUBSCR), lineno=self.line, index=-1)

        # now store the iterated item
        st_iterable = PyToken(op=Opcode(pyop.STORE_FAST), lineno=self.line, index=-1,
                              args=self.list_comp_iterable_variable)

        #
        # the following load the forloop counter and increments it
        #

        # load the counter var
        ld_counter_2 = PyToken(op=Opcode(pyop.LOAD_FAST), lineno=self.line, index=-1,
                               args=self.list_comp_iterable_loopcounter)
        # load the constant 1
        increment_const = PyToken(
            op=Opcode(pyop.LOAD_CONST), lineno=self.line, index=-1, args=1)
        # add it to the counter
        increment_add = PyToken(
            op=Opcode(pyop.INPLACE_ADD), lineno=self.line, index=-1)
        increment_add.func_processed = True
        # and store it again
        increment_store = PyToken(op=Opcode(pyop.STORE_FAST), lineno=self.line, index=-1,
                                  args=self.list_comp_iterable_loopcounter)

        # and now we call the function of the list-comprehension

        list_comp_call_func = PyToken(
            op=Opcode(pyop.CALL_FUNCTION), lineno=self.line, index=-1, args=1)
        list_comp_call_func.func_name = self.local_func_name
        list_comp_call_func.func_params = [self.list_comp_iterable_variable]

        self.oplist = [
            setup_loop,  # SETUP_LOOP

            get_iter,  # GET_ITER, keep this in for now


            # the following 4 ops set up the iterator

            loopcounter_start_ld_const,  # LOAD_CONST 0
            loopcounter_store_fast,  # STORE_FAST forloopcounter_X

            # dynamic load loop stuff would go here



            call_get_length_token,  # CALL_FUNCTION 1

            looplength_store_op,  # STORE_FAST forloop_length_X


            # these last 5 ops controls the operation of the loop

            for_iter,  # tihs is the jump target for the end of the loop execution block

            ld_loopcounter,  # load in the loop counter LOAD_FAST forloopcounter_X

            ld_loop_length,  # load in the loop length LOAD_FAST forloop_length_X

            new__compare_op,  # COMPARE_OP <, this will compare foorloop_counter_X < forloop_length_X

            new__popjump_op,  # POP_JUMP_IF_FALSE jumps to the loop exit when counter == length

            # the following are the loop body items
            ld_load_iterable,

            ld_counter,

            ld_subscript,

            st_iterable,

            ld_counter_2,

            increment_const,

            increment_add,  # this is a hack... when the list_comp_call_func is processed, it
            # takes out a few things from the block
            # so we add it in twice (blerg...) so it gets put back in
            increment_store,

            # put call method of the list comp here...


            # now pop back to for_iter
            jmp_abs_back,

            end_block,
        ]

#        from boa.code.method import Method
#        internal_method = Method(code_object=code_obj,
#                                 parent=method.parent,
#                                 make_func_name=self.local_func_name,
#                                 is_list_comp_internal=True,
#                                 list_comp_iterable_name=self.list_comp_iterable_variable)


#        internal_ops = internal_method.blocks[0].oplist
#        print("internal ops %s " % internal_ops)
#        print(internal_method.tokenizer.to_s())
#        self.oplist = self.oplist[:-2] + internal_ops + self.oplist[-2:]
#        if len(dynamic_iterable_items):
#            self.oplist.insert(4, dynamic_iterable_items[0])
#            self.oplist.insert(5, dynamic_iterable_items[1])

        Block.forloop_counter += 1

    def process_list_comp_internal(self, list_comp_item_name):
        # get rid of first op
        """

        :param list_comp_item_name:
        """
        print("OP 0 %s " % self.oplist[0].py_op)
        if self.oplist[0].py_op == pyop.STORE_FAST:

            argname = self.oplist[0].args

            self.oplist[0] = PyToken(
                op=Opcode(pyop.LOAD_FAST), lineno=self.line, index=0, args=list_comp_item_name)

            method_call = self.oplist[1]

            for op in method_call.func_params:
                print("op in method call:: %s %s " % (op, op.args))
                if op.args == argname:
                    print("switch argname...")
                    op.args = list_comp_item_name

            self.oplist = self.oplist[0:-3]

#        pdb.set_trace()


# XXX END boa/code/block.py

# XXX BEGIN boa/code/method.py
print("loading boa/code/method.py")

#from boa.code.byteplay3 import SetLinenoType, Label, Opcode

#from boa.code.pytoken import PyToken
#from boa.code.vmtoken import VMTokenizer
#from boa.code.block import Block
#from boa.code import pyop

#import dis

#import collections


class Method():
    """
    The method is the main unit of functionality.  Any method can take 0 to many arguments and return 1 value

    Each method contains a variable amount of lines, or ``boa.code.block.Block`` objects, which represent
    discrete units of functionality.

    Each line in split into discrete ``boa.code.pytoken.PyToken`` objects, which are tokens which would be used
    by a python interpreter.

    After this, each line is turned into a block.  Once a block is complete, a variable amount of processing
    happens on the block to turn it into something that the Neo Virtual Machine will understand.

    Once we have a list of processed blocks, we can string them together and feed them to the VMTokenizer

    The VMTokenizer is responsible for turning PyToken objects into VMToken objects.

    When the method has been tokenized, each token then has an address within the method.  Once these addresses are complete,
    the ``convert_jumps`` method is called to tell each flow control operation where (which address) it will need to jump to.
    """

    bp = None

    parent = None

    tokens = None

    tokenizer = None

    local_stores = None

    start_line_no = None

    blocks = None

    method_address = None

    dynamic_iterator_count = 0

    local_methods = None

    __make_func_name = None

    @property
    def name(self):
        """
        Get the name of this method.

        :return: the name of this method
        :rtype: str
        """

        return self.bp.name

    @property
    def full_name(self):
        """
        Get the full name of this method ( with module path ).

        :return: module namespaced name of the method
        :rtype: str
        """

        if self.__make_func_name is None:
            if len(self.module.module_path):
                return '%s.%s' % (self.module.module_path, self.name)
            return self.name
        return self.__make_func_name

    @property
    def args(self):
        """
        Return a list of arguments in this method.

        :return: list of arguments for this method
        :rtype: list
        """

        return self.bp.args

    @property
    def code(self):
        """
        Return the ``byteplay3`` code object.

        :return: the ``byteplay3`` code object of this method
        :rtype: ``byteplay3.Code``
        """

        return self.bp.code

    @property
    def vm_tokens(self):
        """
        Returns a list of all vm tokens in this method.

        :return: a list of vm tokens in this method
        :rtype: list
        """

        return self.tokenizer.vm_tokens

    @property
    def firstlineno(self):
        """
        Get the starting line number of this method.

        :return: starting line number
        :rtype: int
        """

        return self.bp.firstlineno

    @property
    def total_lines(self):
        """
        Get the total number of lines ( aka blocks ) in this method.

        :return: total number of lines
        :rtype: int
        """

        count = 0
        for index, (op, arg) in enumerate(self.code):
            if type(op) is SetLinenoType:
                count += 1

        return count

    @property
    def total_module_variables(self):
        """
        Get the total number of local variables.

        :return: the number of variables in this module
        :rtype: int
        """

        return len(self.module.module_variables)

    @property
    def module(self):
        """
        Retrieves the module this method is a member of.

        :return: the module this method is a member of
        :rtype: ``boa.code.module.Module``
        """

        #from boa.code.module import Module

        if type(self.parent) is Module:
            return self.parent
        elif type(self.parent.parent) is Module:
            return self.parent.parent
        elif type(self.parent.parent.parent) is Module:
            return self.parent.parent.parent

        return None

    def __init__(self, code_object, parent, make_func_name=None):

        self.bp = code_object

        self.parent = parent

        self.__make_func_name = make_func_name

        self.read_module_variables()

        self.read_initial_tokens()

        self.process_block_groups()

        self.tokenize()

        self.convert_jumps()

    def print(self):
        """
        This method prints the output of the method's ``byteplay3`` object
        as it would be seen by a python interpreter.
        Compare this with the ``boa.code.method.Method.to_dis()`` output
        and you will see subtle differences.

        sample output:

        >>> method.print()
              2            STORE_FAST           j
              12         1 LOAD_CONST           9
              14         4 LOAD_CONST           <byteplay3.Code object at 0x10cb5ec88>
                         5 LOAD_CONST           'Main.<locals>.q'
                         6 MAKE_FUNCTION        0
                         7 STORE_FAST           q
              22         9 LOAD_FAST            q
                        10 LOAD_FAST            j
                        11 CALL_FUNCTION        1
                        12 STORE_FAST           m
              24        14 LOAD_FAST            m
                        15 RETURN_VALUE
        """

        print(self.code)

    def to_dis(self):
        """
        This method prints the output of the method as it would be seen
        by a python interpreter.
        compare this to the output of the ``boa.code.method.Method.print()`` and
        you will see some subtle differences.

        >>> method.to_dis()
          3             STORE_FAST               0 (j)
         12           0 LOAD_CONST               1 (9)
         14           6 LOAD_CONST               2 (<code object q at 0x10cbbc810,
                                                   file "./boa/tests/src/LambdaTest.py", line 14>)
                      9 LOAD_CONST               3 ('Main.<locals>.q')
                     12 MAKE_FUNCTION            0
                     15 STORE_FAST               1 (q)
         22          18 LOAD_FAST                1 (q)
                     21 LOAD_FAST                0 (j)
                     24 CALL_FUNCTION            1 (1 positional, 0 keyword pair)
                     27 STORE_FAST               2 (m)
         24          30 LOAD_FAST                2 (m)
                     33 RETURN_VALUE
        """

        out = self.bp.to_code()
        dis.dis(out)

    def read_module_variables(self):
        """
        Take all module ``global`` variables and gives this method access to them.
        """

        for definition in self.module.module_variables:

            items = definition.items

            self.bp.code = items + self.bp.code

    def read_initial_tokens(self):
        """
        Take the initial set of tokens from the ``byteplay3`` code object and turn them into blocks.
        """

        self.blocks = []

        self.local_methods = collections.OrderedDict()

        self.local_stores = collections.OrderedDict()

        current_line_no = None

        block_group = None

        self.tokenizer = VMTokenizer(self)

        current_label = None

        current_loop_token = None

        for i, (op, arg) in enumerate(self.code):

            # print("[%s] %s  ->  %s " % (i, op, arg))

            if type(op) is SetLinenoType:

                current_line_no = arg

                if self.start_line_no is None:
                    self.start_line_no = current_line_no

                if block_group is not None:

                    self.blocks.append(Block(block_group))

                block_group = []

            elif type(op) is Label:

                current_label = op

            else:

                if op in [pyop.STORE_FAST, pyop.STORE_NAME, pyop.STORE_GLOBAL] and arg not in self.local_stores.keys():
                    length = len(self.local_stores)
                    self.local_stores[arg] = length

                token = PyToken(op, current_line_no, i, arg)

                if op == pyop.SETUP_LOOP:
                    current_loop_token = token

                if op == pyop.BREAK_LOOP and current_loop_token is not None:
                    token.args = current_loop_token.args
                    current_loop_token = None

                if current_label is not None:
                    token.jump_label = current_label
                    current_label = None

                block_group.append(token)

        if len(block_group):
            self.blocks.append(Block(block_group))

    def process_block_groups(self):
        """
        Takes the current blocks ( similar to lines in a method ) and
        processes them so they can be tokenized properly.
        """

        iter_setup_block = None

        for index, block in enumerate(self.blocks):

            # if it is a return block
            # we need to insert a jmp at the start of the block
            # for the vm
            if block.is_return:

                # this jump needs to jump 3 bytes.  why? stay tuned to find out
                block_addr = b'\x03\x00'

                ret_token = PyToken(Opcode(pyop.BR_S),
                                    block.line, args=block_addr)
                ret_token.jump_label = block.oplist[0].jump_label
                block.oplist[0].jump_label = None
                block.oplist.insert(0, ret_token)
                block.mark_as_end()
#                length = len(self.local_stores)
#                self.local_stores[block.local_return_name] = length

            if block.has_load_attr:
                block.preprocess_load_attr(self)

            if block.is_list_comprehension:
                block.preprocess_list_comprehension(self)
                for localvar in block.list_comp_iterable_local_vars:
                    if localvar in self.local_stores.keys():
                        pass
                    else:
                        length = len(self.local_stores)
                        self.local_stores[localvar] = length

            if block.has_make_function:
                block.preprocess_make_function(self)
                self.local_methods[block.local_func_varname] = block.local_func_name

            if block.has_unprocessed_array:
                block.preprocess_arrays()

            if block.has_unprocessed_array_sub:
                block.preprocess_array_subs()

            if block.has_unprocessed_method_calls:
                block.preprocess_method_calls(self)

            if block.has_slice:
                block.preprocess_slice()
                if block.slice_item_length is not None:
                    length = len(self.local_stores)
                    self.local_stores[block.slice_item_length] = length

            if iter_setup_block is not None:
                block.process_iter_body(iter_setup_block)
                iter_setup_block = None

            if block.is_iter and not block.is_list_comprehension:
                block.preprocess_iter()
                for localvar in block.iterable_local_vars:

                    if localvar in self.local_stores.keys():
                        pass
                    else:
                        length = len(self.local_stores)
                        self.local_stores[localvar] = length
                iter_setup_block = block
                self.dynamic_iterator_count += 1

        alltokens = []

        for block in self.blocks:
            if block.has_make_function:
                if block.is_list_comprehension:
                    alltokens = alltokens + block.oplist
            else:
                alltokens = alltokens + block.oplist
        self.tokens = alltokens

        for index, token in enumerate(self.tokens):
            token.addr = index

    def tokenize(self):
        """
        Turn a set of ``boa.code.pytoken.PyToken`` objects into ``boa.code.vmtoken.VMToken`` objects.
        """

        self.tokenizer.update_method_begin_items()
        prevtoken = None
        for t in self.tokens:
            t.to_vm(self.tokenizer, prevtoken)
            prevtoken = t

    def convert_jumps(self):
        """
        Convert jumps that occur from flow control items
        such as if, else, for loops, while loops, and breaks.
        """

        for key, vm_token in self.tokenizer.vm_tokens.items():

            if vm_token.pytoken and type(vm_token.pytoken.args) is Label:

                label = vm_token.pytoken.args

                for key2, vm_token_target in self.tokenizer.vm_tokens.items():

                    if vm_token_target.pytoken and vm_token_target.pytoken.jump_label is not None:

                        jump_to_label = vm_token_target.pytoken.jump_label

                        if jump_to_label == label:

                            difference = vm_token_target.addr - vm_token.addr

                            vm_token.data = difference.to_bytes(2, 'little', signed=True)

    def write(self):
        """
        Write the current state of the tokenizer to a byte string.

        :return: a byte string of the current tokenizer
        :rtype: bytes
        """

        out = self.tokenizer.to_b()
        return out


# XXX END boa/code/method.py

# XXX BEGIN boa/code/items.py
print("loading boa/code/items.py")

#from boa.code.byteplay3 import Code, Opcode
#from boa.code.method import Method
#from boa.code import pyop
#import importlib
#import binascii


class Item():
    """

    """
    items = None

    def __init__(self, item_list):
        self.items = item_list

    def is_valid(self):
        """

        :return:
        """
        return True


class Definition(Item):
    pass
#    def __init__(self, item_list):
#        super(Definition, self).__init__(item_list)
#        self.items[-1] = (Opcode(pyop.STORE_FAST),self.items[-1][1])
#       print("self items %s " % self.items)


class Action(Item):

    """

    """
    event_name = None
    event_args = None

    method_name = None

    def __init__(self, item_list):
        super(Action, self).__init__(item_list)

        arguments = []

        for i, (key, value) in enumerate(self.items.items):
            if key == pyop.LOAD_CONST:
                arguments.append(value)
            elif key == pyop.STORE_NAME:
                self.method_name = value

        self.event_name = arguments[0]

        self.event_args = arguments


class SmartContractAppCall(Item):

    """

    """
    script_hash = None
    script_args = None

    method_name = None

    def __init__(self, item_list):
        super(SmartContractAppCall, self).__init__(item_list)

        arguments = []

        for i, (key, value) in enumerate(self.items.items):
            if key == pyop.LOAD_CONST:
                arguments.append(value)
            elif key == pyop.STORE_NAME:
                self.method_name = value

        self.script_hash = arguments[0]

        self.script_args = arguments

        if type(self.script_hash) is str:
            if len(self.script_hash) != 40:
                raise Exception(
                    "Invalid script hash! length of string must be 40")
        elif type(self.script_hash) in [bytes, bytearray]:
            if len(self.script_hash) != 20:
                raise Exception(
                    "Invalid Script hash, length in bytes must be 20")
        else:
            raise Exception(
                "Invalid script hash type.  must be string, bytes, or bytearray")

    @property
    def script_hash_addr(self):
        """

        :return:
        """

        return SmartContractAppCall.ToScriptHashData(self.script_hash)

    @staticmethod
    def ToScriptHashData(item):
        """

        :return:
        """
        b_array = None
        if type(item) is str:
            print("ITEM!! %s " % item)
            bstring = item.encode('utf-8')
            b_array = bytearray(binascii.unhexlify(bstring))
        elif type(item) is bytearray:
            pass
        elif type(item) is bytes:
            print("bytes len %s " % len(item))

            b_array = bytearray(item)
        else:
            raise Exception("Invalid script hash")

        b_array.reverse()

        return bytes(b_array)


class Import(Item):

    """

    """
    NEO_SC_FRAMEWORK = 'neo.SmartContract.Framework.'

    module_path = None
    module_name = None

    imported_module = None

    is_system_module = None

    module_items_to_import = None

    def __init__(self, item_list):
        super(Import, self).__init__(item_list)
        self.module_items_to_import = []

        for i, (op, arg) in enumerate(self.items):
            if op == pyop.IMPORT_NAME:
                self.module_path = arg
            elif op == pyop.STORE_NAME:
                self.module_items_to_import.append(arg)
#                print("SETTING MODALu nAme: %s " % self.module_name)

            elif op == pyop.IMPORT_STAR:
                self.module_items_to_import = ['STAR']

        self.is_system_module = False

        self.build()

    def build(self):
        # here is where we will check imports
        """

        """
        #from boa.code.module import Module  # XXX circular deps

        module = importlib.import_module(self.module_path, self.module_path)

        filename = module.__file__

        if self.NEO_SC_FRAMEWORK in self.module_path:
            self.is_system_module = True

        self.imported_module = Module(filename,
                                      module_name=self.module_path,
                                      is_sys_module=self.is_system_module,
                                      items_to_import=self.module_items_to_import)

    def is_valid(self):
        """

        :return:
        """
        return True

    def __str__(self):
        return "%s.%s" % (self.module_path, self.module_name)


class Klass(Item):

    """

    """
    name = None

    parent_name = None

    parent = None

    methods = None

    bp = None

    module = None

    def __init__(self, item_list, module):
        super(Klass, self).__init__(item_list)
        self.module = self.parent = module
        self.methods = []
        self.build()

    def build(self):
        """

        """
        for i, (op, arg) in enumerate(self.items):

            # if the item is a byteplay3 code object, it is a method
            if type(arg) is Code:
                self.bp = arg

            # load name is called  to gather the class parent
            if op == pyop.LOAD_NAME:
                self.parent_name = arg

            # this occurs to store the name of the class
            if op == pyop.STORE_NAME:
                self.name = arg

#        print('Created class %s inherits from %s ' % (self.name, self.parent))

        # go through code object of the class and extract the method code
        # objects
        for i, (op, arg) in enumerate(self.bp.code):

            if type(arg) is Code:
                self.methods.append(Method(arg, self))

    def is_valid(self):
        # here is where we check if the class extends something reasonable
        """

        :return:
        """
        return True

# XXX END boa/code/items.py

# XXX BEGIN boa/code/module.py
print("loading boa/code/module.py")

#from boa.code.byteplay3 import Code, SetLinenoType, Label
#from boa.code import pyop

#from boa.code.line import Line
#from boa.code.method import Method
#from boa.code.items import Definition, Klass, Import, Action, SmartContractAppCall

#from boa.blockchain.vm import VMOp

#from collections import OrderedDict

#import pdb


class Module():
    """
    A Module is the top level component which contains code objects.
    When, for example, compiling ``path/to/my/file.py``, the items contained in ``file.py`` are the module.
    An executable may have many modules.  The 'default' or 'entry' module in the example above would be ``file.py``

    When calling ``Compiler.load_and_save('path/to/file.py')``, a module is created for ``file.py``.
    If `file.py` imports any other functionality, those modules will also be added to the executable
    and placed in the Module.loaded_modules attribute.

    After modules have been processed as methods, and then methods processed as blocks, and blocks processed to tokens,
    The main or ``default`` module's ``write()`` method is called, which writes the executable to a byte string and returns
    it to be saved to disk.

    If you would like to inspect the contents of a module, you may use the ``Compiler.load('path/to/file.py')`` which will
    return an instance of the compiler.  With that instance, you can access the ``default`` module of the compiler
    which will in turn give you access to any other loaded modules contained in the default module.


    Each module ( as well as each method object ) contains a reference to a ``byteplay3`` object, named ``bp``.
    This object contains the instruction set as it would be viewed in the Python interpreter.

    You can call ``print(module.bp.code)`` on any object with a ``bp`` attribute, and it will output the Python interpreter code.


    >>> from boa.compiler import Compiler
    >>> module = Compiler.load('./boa/tests/src/AddTest1.py').default
    >>> print(module.bp.code)
    2     1 LOAD_CONST           <byteplay3.Code object at 0x10cc3d6a0>
          2 LOAD_CONST           'Main'
          3 MAKE_FUNCTION        0
          4 STORE_NAME           Main
          5 LOAD_CONST           None
          6 RETURN_VALUE


    Once an executable has been processed and tokenized, it will then have a set of vm tokens that are similar
    to the ``byteplay3`` tokens, but different in important ways. These are contained in the module's ``all_vm_tokens`` attribute

    You may call ``module.to_s()`` to view the program as it has been tokenized for the NEO Virtual Machine.


    >>> module.to_s()
    4             31  LOAD_FAST           a                [data]
                  36  LOAD_CONST          2                [data]
                  37  BINARY_MULTIPLY                      [data]
                  38  STORE_FAST          a2               [data]
    6             45  LOAD_FAST           b                [data]
                  50  LOAD_CONST          1                [data]
                  51  BINARY_ADD                           [data]
                  52  STORE_FAST          b2               [data]
    8             59  LOAD_FAST           c                [data]
                  64  LOAD_CONST          2                [data]
                  65  BINARY_TRUE_DIVIDE                   [data]
                  66  STORE_FAST          c2               [data]
    10            73  LOAD_FAST           d                [data]
                  78  LOAD_CONST          1                [data]
                  79  BINARY_SUBTRACT                      [data]
                  80  STORE_FAST          d2               [data]
    13            87  243                 b'\x03\x00'      [data] 3
                  90  LOAD_FAST           a2               [data]
                  95  LOAD_FAST           b2               [data]
                  100 BINARY_ADD                           [data]
                  101 LOAD_FAST           c2               [data]
                  106 BINARY_ADD                           [data]
                  107 LOAD_FAST           d2               [data]
                  112 BINARY_ADD                           [data]
                  113 NOP                                  [data]
                  114 241                                  [data]
                  115 242                                  [data]
                  116 RETURN_VALUE                         [data]
    """

    bp = None  # this is to store the byteplay reference

    path = None  # the path where this file is

    lines = None  # this contains the code objects split up into different line start indexes

    imports = None  # a list of import statements

    module_variables = None  # list of module variables

    classes = None  # a list of classes

    methods = None  # a list to keep all methods in the module

    actions = None  # a list to keep track of event registrations

    app_call_registrations = None  # a list to keep track of app call registrations

    is_sys_module = None

    all_vm_tokens = None  # dict for converting method tokens into linked method tokens for writing

    loaded_modules = None

    _module_name = None

    _names_to_load = None

    @property
    def module_path(self):
        """
        Return the file path of the module.

        :return: the path of the module
        :rtype: str
        """

        return self._module_name

    @property
    def main(self):
        """
        Return the default method in this module.

        :return: the default method in this module
        :rtype: ``boa.code.method.Method``
        """

        for m in self.methods:

            if m.name == 'Main':
                return m

        if len(self.methods):
            return self.methods[0]

        return None

    @property
    def orderered_methods(self):
        """
        An ordered list of methods

        :return: A list of ordered methods is this module
        :rtype: list
        """

        oms = []

        self.methods.reverse()

        if self.main:
            oms = [self.main]

        for m in self.methods:

            if m == self.main:
                continue
            oms.append(m)

        return oms

    def add_method(self, method):
        """
        Add a method to this module.

        :param method: the method object to add to this module
        :type method: ``boa.code.method.Method``

        :return: whether the method was added
        :rtype: bool
        """

        for m in self.methods:

            if m.name == method.name:

                if m.name != m.full_name:

                    if m.full_name == method.full_name:
                        return False
                else:
                    return False
                # return False

        # print("appending method %s %s " % (method.name, method.full_name))
        self.methods.append(method)

        return True

    def method_by_name(self, method_name):
        """
        Look up a method by its name from the module ``methods`` list.
        :param method_name: the name of the method to look up
        :type method_name: str

        :return: the method ( if it is found)
        :rtype: ``boa.code.method.Method``
        """

        for m in self.methods:
            if m.full_name == method_name:
                return m
            elif m.name == method_name:
                return m
        return None

    def __init__(self, path, module_name='', is_sys_module=False, items_to_import=None):

        #self.path = path

        self._module_name = module_name

        self.is_sys_module = is_sys_module

        self._names_to_load = ['STAR'] if items_to_import is None else items_to_import

        code = ''
        path2 = '<string>'
        if path.endswith('Runtime.py') and path.startswith('/'):
            print("WONT LOAD! HAVE CACHE FOR RUNTIME.PY!!")
            code = '\n\ndef GetTrigger():\n    """\n\n    """\n    pass\n\n\ndef CheckWitness(hash_or_pubkey):\n    """\n\n    :param hash_or_pubkey:\n    """\n    pass\n\n\ndef Log(message):\n    """\n\n    :param message:\n    """\n    pass\n\n\ndef Notify(arg):\n    """\n\n    :param arg:\n    """\n    pass\n'
        elif path.endswith('.py')  and path.startswith('/'):
            path2 = path
            source = open(path, 'rb')
            code = source.read()
            source.close()
            print("reading from ",path," returned=",code)
        else:
            code = path   # passed source code directly as path
        print()
        print("will compile()")
        suite = compile(code, path2, 'exec')

        self.bp = Code.from_code(suite)

        self.build()

    def build(self):
        """
        Split the ``bp.code`` object into lines, and assembles the lines into different items.
        """

        self.lines = []
        self.imports = []
        self.module_variables = []
        self.methods = []
        self.actions = []
        self.app_call_registrations = []
        self.classes = []
        self.loaded_modules = []

        self.split_lines()

        for lineset in self.lines:

            if lineset.is_import:

                if not self.is_sys_module:
                    imp = Import(lineset.items)
                    self.process_import(imp)
                else:
                    print("will not import items from sys module")

            elif lineset.is_docstring:
                pass
            elif lineset.is_definition:
                self.module_variables.append(Definition(lineset.items))
            elif lineset.is_class:
                self.classes.append(Klass(lineset.items, self))
            elif lineset.is_method:
                self.process_method(lineset)
            elif lineset.is_action_registration:
                self.process_action(lineset)
            elif lineset.is_smart_contract_appcall_registration:
                self.process_smart_contract_app_registration(lineset)
            else:
                print('not sure what to do with line %s ' % lineset)
                pdb.set_trace()

    def process_import(self, import_item):
        """
        Processes an import statement within this module.

        :param import_item:
        :type import_item: ``boa.code.items.Import subclass``
        """

        self.imports.append(import_item)

        self.loaded_modules.append(import_item.imported_module)

        # Go through all the methods in the imported module.
        for method in import_item.imported_module.methods:
            self.add_method(method)

    def process_method(self, lineset):
        """
        processes a set of lines that contain a byteplay3 code object

        :param lineset: the lineset to process and add
        :type lineset: list
        """

        m = Method(lineset.code_object, self)

        if 'STAR' in self._names_to_load:
            self.add_method(m)
        else:
            for item in self._names_to_load:

                if item == m.name:
                    self.add_method(m)

    def process_action(self, lineset):
        """
        Processes an action within this module.
        A sample action would be to create an event like so:

        .. code-block:: python

            from boa.blockchain.vm.Neo.Action import RegisterAction

            # Register the action.
            onRefund = RegisterAction('refund', 'to_address', 'amount')

            # Dispatch an action.
            onRefund(my_address, 100)

        :param lineset: The set of lines containing an app call registration
        :type lineset: list
        """

        action = Action(lineset)
        for act in self.actions:
            if act.method_name == action.method_name:
                return None

        self.actions.append(action)

    def process_smart_contract_app_registration(self, lineset):
        """
        processes a smart contract app registration, for when you would like to call another
        smart contract from your contract.  for example:

        .. code-block:: python

            from boa.blockchain.vm.Neo.App import RegisterAppCall

            # register the contract
            otherContract = RegisterAppCall('contract_hash', 'param1','param2')

            # call the contract
            result = otherContract( a, b )

        :param lineset: The set of lines containing an app call registration
        :type lineset: list
        """

        appcall_registration = SmartContractAppCall(lineset)
        for registration in self.app_call_registrations:
            if registration.method_name == appcall_registration.method_name:
                return
        self.app_call_registrations.append(appcall_registration)

    def split_lines(self):
        """
        Split the list of lines in the module into a set of objects that can be interpreted.
        """

        lineitem = None

        for i, (op, arg) in enumerate(self.bp.code):

            if isinstance(op, SetLinenoType):
                if lineitem is not None:
                    self.lines.append(Line(lineitem))

                lineitem = []

            lineitem.append((op, arg))

        if len(lineitem):
            self.lines.append(Line(lineitem))

    def write(self):
        """
        Write the current module to a byte string.

        Note that if you are using the ``Compiler.load('path/to/file.py')``, you must
        call ``module.write()`` before any inspection of the module is possible.

        :return: A bytestring of representing the current module
        :rtype: bytes
        """
        self.link_methods()

        return self.write_methods()

    def write_methods(self):
        """
        Write all methods in the current module to a byte string.

        :return: A bytestring of all current methods in this module
        :rtype: bytes
        """

        b_array = bytearray()
        for key, vm_token in self.all_vm_tokens.items():

            b_array.append(vm_token.out_op)

            if vm_token.data is not None and vm_token.vm_op != VMOp.NOP:
                b_array = b_array + vm_token.data

        return b_array

    def link_methods(self):
        """
        Perform linkage of addresses between methods.
        """

        self.all_vm_tokens = OrderedDict()

        address = 0

        for method in self.orderered_methods:
            method.method_address = address

            for key, vmtoken in method.vm_tokens.items():
                self.all_vm_tokens[address] = vmtoken

                address += 1

                if vmtoken.data is not None:
                    address += len(vmtoken.data)

                vmtoken.addr = vmtoken.addr + method.method_address

        for key, vmtoken in self.all_vm_tokens.items():
            if vmtoken.src_method is not None:
                target_method = self.method_by_name(vmtoken.target_method)
                if target_method:

                    jump_len = target_method.method_address - vmtoken.addr
                    vmtoken.data = jump_len.to_bytes(2, 'little', signed=True)
                else:
                    raise Exception("Target method %s not found" % vmtoken.target_method)

    def to_s(self):
        """
        this method is used to print the output of the executable in a readable/ tokenized format.
        sample usage:

        >>> from boa.compiler import Compiler
        >>> module = Compiler.load('./boa/tests/src/LambdaTest.py').default
        >>> module.write()
        >>> module.to_s()
        12            3   LOAD_CONST          9                [data]
                      4   STORE_FAST          j                [data]
        22            11  LOAD_FAST           j                [data]
                      17  CALL_FUNCTION       Main.<locals>.q_1 \
                                          [<boa.code.pytoken.PyToken object at 0x10cb53c50>] [data] 22
                      20  STORE_FAST          m                [data]
        24            27  243                 b'\x03\x00'      [data] 3
                      30  LOAD_FAST           m                [data]
                      35  NOP                                  [data]
                      36  241                                  [data]
                      37  242                                  [data]
                      38  RETURN_VALUE                         [data]
        20            49  243                 b'\x03\x00'      [data] 3
                      52  LOAD_FAST           x                [data]
                      57  LOAD_CONST          1                [data]
                      58  BINARY_ADD                           [data]
                      59  NOP                                  [data]
                      60  241                                  [data]
                      61  242                                  [data]
                      62  RETURN_VALUE                         [data]
        """

        lineno = 0
        pstart = True

        for i, (key, value) in enumerate(self.all_vm_tokens.items()):
            if value.pytoken:
                pt = value.pytoken
                do_print_line_no = False
                to_label = None
                from_label = '    '

                if pt.line_no != lineno:
                    print("\n")
                    lineno = pt.line_no
                    do_print_line_no = True

                if pt.args and type(pt.args) is Label:
                    addr = value.addr
                    if value.data is not None:
                        plus_addr = int.from_bytes(
                            value.data, 'little', signed=True)
                        target_addr = addr + plus_addr
                        to_label = 'to %s    [ %s ]' % (target_addr, pt.args)
                    else:
                        to_label = 'from << %s ' % pt.args
                        #                    to_label = 'to %s ' % pt.args
                elif pt.jump_label:
                    from_label = ' >> '
                    to_label = 'from [%s]' % pt.jump_label

                ds = ''
                if value.data is not None:
                    try:
                        ds = int.from_bytes(value.data, 'little', signed=True)
                    except Exception as e:
                        pass
                    if type(ds) is not int and len(ds) < 1:
                        try:
                            ds = value.data.decode('utf-8')
                        except Exception as e:
                            pass

                if pt.py_op == pyop.CALL_FUNCTION:
                    to_label = '%s %s ' % (pt.func_name, pt.func_params)

                lno = "{:<10}".format(
                    pt.line_no if do_print_line_no or pstart else '')
                addr = "{:<4}".format(key)
                op = "{:<20}".format(str(pt.py_op))
                arg = "{:<50}".format(
                    to_label if to_label is not None else pt.arg_s)
                data = "[data] {:<20}".format(ds)
                print("%s%s%s%s%s%s" % (lno, from_label, addr, op, arg, data))

            pstart = False


# XXX END boa/code/module.py

# XXX BEGIN boa/compiler.py
print("loading boa/compiler.py")

#import os
#from boa.code.module import Module


class Compiler():
    """
    The main compiler interface class.

    The following loads a python file, compiles it to the `.avm` format
    and saves it alongside the python file.

    .. code-block:: python

        from boa.compiler import Compiler
        Compiler.load_and_save('path/to/your/file.py')

        # return the compiler object for inspection
        compiler = Compiler.load('path/to/your/file.py')

        # retrieve the default module for inpection
        default_module = compiler.default

        # retreive the default/entry method for the smart contract
        entry_method = default_module.main
    """

    __instance = None

    modules = None

    def __init__(self):
        self.modules = []

    @staticmethod
    def instance():
        """
        Retrieve the current instance of the Compiler object, if it exists,
        or create one.

        :return: the singleton instance of the Compiler object
        """

        if not Compiler.__instance:
            Compiler.__instance = Compiler()
        return Compiler.__instance

    @property
    def default(self):
        """
        Retrieve the default or 'entry' module.

        :return: the default `boa.code.Module` object or None upon exception
        """

        try:
            return self.modules[0]
        except Exception as e:
            pass

    @staticmethod
    def write_file(data, path):
        """
        Save the output data to the file system at the specified path.

        :param data: a byte string of data to write to disk
        :param path: the path to write the file to
        """

        with open(path, 'wb+') as out_file:
            out_file.write(data)

    def write(self):
        """
        Write the default module to a byte string.

        :return: the compiled Python program as a byte string
        :rtype: bytes
        """

        module = self.default
        out_bytes = bytes(module.write())

        return out_bytes

    @staticmethod
    def load_and_save(path, output_path=None):
        """
        Call `load_and_save` to load a Python file to be compiled to the .avm format and save the result.
        By default, the resultant .avm file is saved along side the source file.

        :param path: The path of the Python file to compile
        :param output_path: Optional path to save the compiled `.avm` file
        :return: the instance of the compiler

        The following returns the compiler object for inspection

        .. code-block:: python

            from boa.compiler import Compiler

            Compiler.load_and_save('path/to/your/file.py')
        """

        compiler = Compiler.load(path)
        data = compiler.write()

        if output_path is None:
            fullpath = os.path.realpath(path)
            path, filename = os.path.split(fullpath)
            newfilename = filename.replace('.py', '.avm')
            output_path = '%s/%s' % (path, newfilename)

        Compiler.write_file(data, output_path)

        return data

    @staticmethod
    def load(path):
        """
        Call `load` to load a Python file to be compiled but not to write to .avm

        :param path: the path of the Python file to compile
        :return: The instance of the compiler

        The following returns the compiler object for inspection.

        .. code-block:: python

            from boa.compiler import Compiler

            compiler = Compiler.load('path/to/your/file.py')
        """

        Compiler.__instance = None

        compiler = Compiler.instance()

        module = Module(path)
        compiler.modules.append(module)

        return compiler

# XXX END boa/compiler.py

# XXX BEGIN boacompiler.py
print("loading boacompiler.py")

#import os
#import sys
#import boa.code.byteplay3
#from boa.compiler import Compiler


def letscompile():
    input_file_dir  = '/home/imcoelho/neo-boa/input-contracts'  #'../../python-contracts'
    output_file_dir = '/home/imcoelho/neo-boa/output-contracts' #'../../compiled-contracts'
    for file in os.listdir(input_file_dir):
        if file.endswith('.py'):
            print()
            print("============================================================")
            print(file)
            file_name = file.replace('.py','')
            input_file_path = os.path.join(input_file_dir, file)
            output_file = file_name + '.avm'
            output_file_path = os.path.join(output_file_dir, output_file)
            Compiler.load_and_save(path=input_file_path, output_path=output_file_path)
            print('Compiled ' + file)
            x = input()

def compilecode(code):
    code = 'from boa.blockchain.vm.Neo.Runtime import Notify\n\n\ndef Main():\n    """\n\n    :return:\n    """\n    items = [1, 3]\n\n#    j = 0\n#    for i in items:\n#        j += i\n#    i2 = [i+1 if i > 0 else i + 5 for i in items]\n\n#    m = 0\n    [Notify(i) for i in items]  # this is not working\n\n    m = 3\n\n    return m\n'
    compiler = Compiler.load(code)
    data = compiler.write()
    return data


def hello():
    return "hello"

# XXX END boacompiler.py



def echo(event):
    alert("texto: ",document["zone"].value)
    alert(hello())
    alert(compilecode(""))
    #alert(MathX.MainX(1,2))

document['mybutton'].bind('click', echo)
</script>

            <textarea id="zone"></textarea><button id="mybutton">click !</button>

        </body>

    </html>
